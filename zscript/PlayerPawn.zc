enum Bobbing
{
	Bob_Normal,
	Bob_Inverse,
	Bob_Alpha,
	Bob_InverseAlpha,
	Bob_Smooth,
	Bob_InverseSmooth,
	Bob_Build,
	Bob_Dusk,
	Bob_Painkiller,
	Bob_UT
}

class PlayerPawnBase : PlayerPawn
{
	TextureID dashTex;
	float alphaFade;
	
	bool InSlime;
	int	SlimeSoundCooler;
	
	bool IsTank;
	Property IsTank : IsTank;
	int tankdeathcounter;
	int tankspritecounter;
	bool baseweaponpda;
	TankBaseNotReal TankBaseSprite; //tank's fake sprite as the actor.
	Actor TankTurretSprite;
	string TankTurretSpriteActor;
	Property TankTurretSpriteActor: TankTurretSpriteActor;
	Array<String> CollectedWeapons, BaseWeapons;
	
	///////////////////////////////////
	//Common
	
	//Movement General
	bool	Pain;
	bool	StrafeRunning;
	double	ViewAngleDelta;
	float	ActualSpeed;
	float	MaxAirSpeed;
	float 	MaxGroundSpeed;
	float	ZMoveFactor;
	int		AnimateJump;
	int		OldRealFloorZ;
	int		RealFloorZ;
	sector	RealFloor;
	vector2	Acceleration;
	vector3	Acceleration3;
	
	//////////////////
	
	//Jumping
	bool 	BlockJump;
	bool	ZMJumpTics;
	float	FloorAngle;
	int		JumpSoundCooler;
	vector3	FloorNormal;
	
	//Double Jump
	bool	BlockDoubleJump;
	bool	CanDoubleJump;
	
	//Elevator Jumps
	float	ElevatorJumpBoost;
	int		OldSecIndex;
	
	//////////////////
	
	//Double Tap
	int		FirstTapTime;
	int		FirstTapValue;
	int		OldTapValue;
	
	//Dashing
	float	WJumpSpeed;
	int		DashNumber;
	int		DashCooler;
	
	//Air Dashing
	float	ADashTargetSpeed;
	int		ADashCooler;
	int		ADashFrictionDelay;
	
	//WallJump
	int		CheckForWJump;
	
	//WallSlideMove
	bool	CanWSlide;
	int		CheckForWSlide;
	vector2	WSlideVelocity;
	
	//Crouch Slide
	bool	CanCSlide;
	float	MaximumSlideSpeed;
	float	QSlideDuration;
	int		CSlideStartTime;
	
	//Ledge Grabbing
	bool	LedgeGrabbed;
	float	LedgeAngle;
	int		LedgeHeight;
	int		LedgeTime;
	weapon	ReselectWeapon;
	
	//Grappling Hook
	actor	GrappledMonster;
	actor	HookFired;
	bool	Grappled;
	float	PendulumLength;
	vector3	GrappleVel;
	vector3 Rope;
	
	//////////////////
	
	//View Bobbing
	bool	PostLandingBob;
	float	ZMBob;
	
	//Weapon Bobbing
	bool	HoppingBob;
	double	BobRangeMulti;
	double	MaxBob;
	double	MoveRangeMulti;
	double	StillRangeMulti;
	double	XBob;
	double	XBobOffset;
	double	YBob;
	float	BobTime;
	
	///////////////////////////////////
	//Painkiller only
	
	//Movement
	bool	TrickFailed;
	float	AirControl;
	float	ActualMaxAirSpeed;
	
	//Jumping
	float	TrickJumpAngle;
	int		SmallerJumpHeight;
	
	///////////////////////////////////
	//Build Engine Only
	
	//Movement
	bool	DeepWater;
	float	LandingVelZ;
	int		FVel;
	int		SVel;
	int		UVel;
	
	//Jumping
	int		BuildJumpDelay;
	
	Default
    {
		Player.DisplayName "ZMovement Player";
        PainChance 255;
    }
	
	////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////
	////																						////
	//// Non-Movement Stuff																		////
	////																						////
	////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////
	
	//Because GZDoom's Unit() returns NaN if a vector has no value
	vector3 SafeUnit3(Vector3 VecToUnit)
	{
		if(VecToUnit.Length()) { VecToUnit /= VecToUnit.Length(); }
		return VecToUnit;
	}
	
	vector2 SafeUnit2(Vector2 VecToUnit)
	{
		if(VecToUnit.Length()) { VecToUnit /= VecToUnit.Length(); }
		return VecToUnit;
	}
	
	Override void PlayerThink()
	{
		let player = self.player;
		UserCmd cmd = player.cmd;
		
		//Set some basic parameters
		ActualSpeed = Speed * GetPowerSpeed();
		bNOFRICTION = True;
		GetFloorInfo();
		MaxGroundSpeed = pb_maxgroundspeed * ActualSpeed;
		Pain = InStateSequence(CurState, FindState("Pain"));
		Player.OnGround = Pos.Z <= FloorZ || bONMOBJ || bMBFBOUNCER || (Player.Cheats & CF_NOCLIP2);
		StrafeRunning = cmd.forwardmove && cmd.sidemove;
		ZMoveFactor = ZMScale();
		
		
		//Execute Player tic cycle
		Super.PlayerThink();
		
		//Bob weapon stuff
		BobWeaponAuxiliary();
		
		//Old values for comparisons
		OldRealFloorZ = RealFloorZ;
	}
	
	float GetAlphaFade()
	{
		return alphaFade;
	}
	
	void GetFloorInfo()
	{
		[RealFloorZ, RealFloor] = FloorSector.NextLowestFloorAt(Pos.X, Pos.Y, Pos.Z, FFCF_3DRESTRICT, MaxStepHeight);
		FloorNormal = RealFloor.FloorPlane.Normal;
	}
	
	float GetPowerSpeed()
	{
		float factor = 1.f;
		
		if(!player.morphTics)
		{
			for(let it = Inv; it != null; it = it.Inv)
			{
				factor *= it.GetSpeedFactor();
			}
		}
		
		return factor;
	}
	
	Override void DeathThink()
	{
		bNOFRICTION = False;
		Gravity = pb_setgravity;
		
		Super.DeathThink();
	}
	
	Override void CalcHeight()
	{
		let player = self.player;
		UserCmd cmd = player.cmd;
		
		double HeightAngle;
		double bob;
		bool still = false;

		if(!Player.OnGround || (Player.OnGround && ((cmd.buttons & BT_JUMP) && !BlockJump)) || player.cheats & CF_NOCLIP2) //nobody walks in the air
		{
			ZMBob--;
			ZMBob = max(bNOGRAVITY ? 0.5f : 0.f, ZMBob);
			PostLandingBob = True;
		}
		else
		{
			if(PostLandingBob)
			{
				ZMBob += Vel.XY.Length() / (MaxGroundSpeed ? MaxGroundSpeed : 1.f);
				if(ZMBob >= Vel.XY.Length() * player.GetMoveBob()) { PostLandingBob = False; }
			}
			else
			{
				ZMBob = Vel.XY.Length() * player.GetMoveBob(); //this way all GetMoveBob() values are meaningful
			}
			
			if(!ZMBob)
				still = true;
			else
				ZMBob = min(MaxGroundSpeed, ZMBob);
		}

		double defaultviewheight = ViewHeight + player.crouchviewdelta;

		if(player.cheats & CF_NOVELOCITY)
		{
			player.viewz = pos.Z + defaultviewheight;

			if(player.viewz > ceilingz-4)
				player.viewz = ceilingz-4;

			return;
		}

		if(still)
		{
			if(player.health > 0)
			{
				HeightAngle = Level.maptime / (120 * TICRATE / 35.) * 360.;
				bob = player.GetStillBob() * sin(HeightAngle);
			}
			else
			{
				bob = 0;
			}
		}
		else
		{
			HeightAngle = Level.maptime / 20. * 360.;
			bob = ZMBob * sin(HeightAngle) * (waterlevel > 2 ? 0.25f : 0.5f);
		}
		
		if(player.morphTics) { bob = 0; }
		
		//////////////////////////////////////////////////////
		// Customizable Landing
		
		if(zm_landing || pb_movetype == 1)
		{
			if(player.playerstate == PST_LIVE)
			{
				if(!Player.OnGround)
				{
					if(Vel.Z >= 0)
					{
						player.viewheight += player.deltaviewheight;
						player.deltaviewheight += zm_landingspeed * 2.f; //ensure a speedy recovery while in the air
						if(player.viewheight >= defaultviewheight)
						{
							player.deltaviewheight = 0;
							player.viewheight = defaultviewheight;
						}
					}
					else
					{
						LandingVelZ = abs(Vel.Z);
						player.deltaviewheight = Vel.Z / zm_landingsens;
						player.viewheight = defaultviewheight;
					}
				}
				else
				{
					player.viewheight += player.deltaviewheight;

					if(player.viewheight > defaultviewheight)
					{
						player.viewheight = defaultviewheight;
						player.deltaviewheight = 0;
					}
					else if(player.viewheight < defaultviewheight * zm_minlanding && !BuildJumpDelay)
					{
						player.viewheight = defaultviewheight * zm_minlanding;
						if(player.deltaviewheight <= 0) { player.deltaviewheight = 1 / 65536.f; }
					}
					
					if(player.deltaviewheight)	
					{
						player.deltaviewheight += zm_landingspeed;
						if(!player.deltaviewheight) { player.deltaviewheight = 1 / 65536.f; }
					}
				}
			}
		}
		else //regular Doom landing
		{
			if(player.playerstate == PST_LIVE)
			{
				player.viewheight += player.deltaviewheight;

				if(player.viewheight > defaultviewheight)
				{
					player.viewheight = defaultviewheight;
					player.deltaviewheight = 0;
				}
				else if(player.viewheight < (defaultviewheight/2))
				{
					player.viewheight = defaultviewheight/2;
					if(player.deltaviewheight <= 0)
						player.deltaviewheight = 1 / 65536.;
				}
				
				if(player.deltaviewheight)	
				{
					player.deltaviewheight += 0.25;
					if(!player.deltaviewheight) { player.deltaviewheight = 1/65536.; }
				}
			}
		}
			
		//Let's highlight the important stuff shall we?
		player.viewz = pos.Z + player.viewheight + (bob * clamp(ViewBob, 0., 1.5));
		
		if(Floorclip && player.playerstate != PST_DEAD && pos.Z <= floorz) { player.viewz -= Floorclip; }
		if(player.viewz > ceilingz - 4) { player.viewz = ceilingz - 4; }
		if(player.viewz < FloorZ + 4) { player.viewz = FloorZ + 4; }
	}
	
	Override void CheckPitch()
	{
		let player = self.player;
		
		int clook = player.cmd.pitch;
		if(clook != 0)
		{
			if(clook == -32768)
			{
				player.centering = true;
			}
			else if(!player.centering)
			{
				A_SetPitch(Pitch - clook * (360. / 65536.), SPF_INTERPOLATE);
			}
		}
		
		if(player.centering)
		{
			if(abs(Pitch) > 2.)
			{
				Pitch *= (2. / 3.);
			}
			else
			{
				Pitch = 0.;
				player.centering = false;
				if(PlayerNumber() == consoleplayer)
				{
					LocalViewPitch = 0;
				}
			}
		}
	}
	
	////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////
	////																						////
	//// Movement Stuff																			////
	////																						////
	////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////
	
	Override void HandleMovement()
	{
		let player = self.player;
		UserCmd cmd = Player.cmd;
		
		//Slime Dissolving sound effect
		CheckSlime();
		if (SlimeSoundCooler) {SlimeSoundCooler--;}
			if(InSlime == true){
				if(!SlimeSoundCooler)
					A_Startsound("world/barrelloop", 12, CHANF_LOOPING  );
					SlimeSoundCooler = 8;
		}
		
		// [RH] Check for fast turn around
		if(player.cmd.buttons & BT_TURN180 && !(player.oldbuttons & BT_TURN180)) { player.turnticks = TURN180_TICKS; }

		// Handle movement
		if(reactiontime)
		{ // Player is frozen
			reactiontime--;
		}
		else
		{	
			ViewAngleDelta = cmd.Yaw * (360.0 / 65536.0); //needed for two other things
			
			if(Player.TurnTicks) //moved here to save many doubled lines
			{
				Player.TurnTicks--;
				A_SetAngle(Angle + (180.0 / TURN180_TICKS), SPF_INTERPOLATE);
			}
			else
			{
				A_SetAngle(Angle + ViewAngleDelta, SPF_INTERPOLATE);
				if(LedgeGrabbed) { Angle = clamp(Angle, LedgeAngle - 20, LedgeAngle + 20); }
			}
			
			/////////////////////////////////////////
			//Acrobatics triggers
			if(CVar.GetCVar("pb_doubletap", Player).GetBool()) { DoubleTapCheck(); }
			//Dashing parameters reset
			if(DashCooler == 100 && (Player.OnGround || WaterLevel >= 2 || bNOGRAVITY))
			{
				WJumpSpeed = DashNumber = 0;
				DashCooler = 18;
				A_TakeInventory("PlayerDashed", 1);
					
			}
			else if(DashCooler && DashCooler <= 18)
			{
				DashCooler--;
				if(alphaFade < 1.0) {
					alphaFade += 0.1;
				}
			}
			//Air Dash
// 			if(pb_airdash)
// 			{
// 				if(ADashCooler) { ADashCooler--; }
// 				if(ADashTargetSpeed) { AirDashFriction(); }
// 			}
			//Wall Jumping
			if(CheckForWJump) { DashInitiator(); }
			//Crouchsliding
			if(pb_crouchslide) { CSlideInitiator(); }
			
			/////////////////////////////////////////
			//Gravity
			DGravity();
			
			/////////////////////////////////////////
			//Actual Movement selection
			if(GrappleVel.Length())
			{
				GrapplingMove();
			}
			else if(LedgeGrabbed)
			{
				LedgeGrab();
			}
			else if(WaterLevel >= 2)
			{
				if(!pb_movetype)
					DoomWaterMove();
				
				if(pb_ledgegrab) { LedgeGrabInitiator(); }
			}
			else if(bNOGRAVITY)
			{
				if(!pb_movetype)
					DoomFlyMove();
			}
			else if(CanCSlide)
			{
				if(pb_cslidetype)
					QSlideMove();
				else
					CSlideMove();
				
				if(pb_movetype == 1) { LandingVelZ = 0.f; }
			}
			else
			{
				if(!pb_movetype)
					DoomHandleMove();
			}
			
			/////////////////////////////////////////
			//Jumping
			CheckJump();
			
			/////////////////////////////////////////
			//Misc
			if(Player.Cheats & CF_REVERTPLEASE != 0)
			{
				Player.Cheats &= ~CF_REVERTPLEASE;
				Player.Camera = Player.Mo;
			}
			
			CheckMoveUpDown();
		}
	}
	
	void CheckSlime()
	{
		sector sss=floorsector;
		if(player.health > 0 && A_CheckFloor("null") && sss.damagetype == "Slime" && !pb_hazardmovement) {
			InSlime = true;
		}
		else {
			InSlime = false;
			A_StopSound(12);
			SlimeSoundCooler = 0;
		}
	}
	
	
	//////////////////////////////////////////
	// Jumping								//
	//////////////////////////////////////////
	
	void PreJumpCommon()
	{
		let player = self.player;
		
		//Jump Sound Cooler
		if(JumpSoundCooler) { JumpSoundCooler--; }
		
		//Double Jump
		if(Player.OnGround) { CanDoubleJump = True; }
		
		//Jumptics settings
		if(ZMJumpTics && (Player.OnGround || WaterLevel >= 2 || bNOGRAVITY)) { ZMJumpTics = False; }
		
		//Dash settings
		if(DashNumber && !ZMJumpTics)
		{
			ZMJumpTics = True;
			bOnMobJ = False;
		}
	}
	
	float GetPowerJump()
	{
		Float JumpFac = 0.f;
		
		for(let p = Inv; p != null; p = p.Inv)
		{
			let pp = PowerHighJump(p);
			if(pp) { JumpFac = max(JumpFac, pp.Strength); }
		}
		
		return JumpFac;
	}
	
	bool, bool CheckIfJumpable()
	{
		if(CeilingZ - RealFloorZ <= Height) //sector is just high enough for player to pass through but not jump
		{
			return True, False;
		}
		else if(FloorSector)
		{
			FloorAngle = atan2(FloorNormal.XY.Length(), FloorNormal.Z);
			
			if(!FloorAngle) //flat surface
			{
				return BlockJump ? True : False, False;
			}
			else
			{
				if(FloorAngle >= 45)
					return Player.OnGround ? True : False, True; //floor is too steep
				else
					return BlockJump ? True : False, True; //you can jump, BUT YOU CANNOT ~~HIDE~~ ELEVATE!!
			}
		}
		else // whatever else
		{
			return BlockJump ? True : False, False;
		}
    }
	
	void ElevatorJump(bool SlopedFloor)
	{
		Int SecIndex = RealFloor.Index();
		Bool CheckForElevator = Player.OnGround && SecIndex == OldSecIndex && !SlopedFloor;
		
		if(pb_elevatorjump)
		{
			if(CheckForElevator && RealFloorZ > OldRealFloorZ) //no accidental elevator jump boost on slopes
				ElevatorJumpBoost = (RealFloorZ - OldRealFloorZ) * pb_ejumpmultiplier;
			else
				ElevatorJumpBoost = 0;
		}
		else
		{
			if(CheckForElevator && RealFloorZ - OldRealFloorZ >= pb_jumpheight / 2.f) { BlockJump = True; } //floor is raising too fast to not spam jump
			ElevatorJumpBoost = 0;
		}
		
		OldSecIndex = SecIndex;
	}
	
	void DGravity()
	{
		if(WaterLevel >= 2)
		{
			if(Vel.Length() < MaxGroundSpeed / 3.f)
				Gravity = 0.5f;
			else
				Gravity = 0.f;
		}
		else if(bNOGRAVITY || GrappleVel.Length())
		{
			Gravity = 0.f;
		}
		else
		{
			Gravity = pb_setgravity;
		}
	}
	
	Override void CheckJump()
	{
		let player = self.player;
		
		//Common stuff
		PreJumpCommon();
		
		//underwater/flying specific jump behavior are in WaterMove and FlyMove
		if(WaterLevel >= 2 || bNOGRAVITY) { return; }
		
		//Check slope angle and sector height
		Bool SlopedFloor;
		[BlockJump, SlopedFloor] = CheckIfJumpable();
		
		//Elevators Jump Boost
		ElevatorJump(SlopedFloor);
		
		
		////////////////////////////////
		//Actual Jump
		if(player.cmd.buttons & BT_JUMP)
		{
			//Special circumstances jump denial
			if(LedgeGrabbed || GrappleVel.Length()) { return; }
			
			if(player.crouchoffset != 0)
			{
				player.crouching = 1;
			}
			
			//Check if player is above a damaging floor. We don't cheese map design here!
			sector sss=floorsector;
			if(A_CheckFloor("null") && sss.damagetype == "Slime" && !pb_hazardmovement) {
				if(!JumpSoundCooler)
					A_Playsound("Daedabus/impact", CHAN_BODY);
					JumpSoundCooler = 4;
				return;
			}
		
			else if(Player.OnGround && !BlockJump && !FindInventory("GoFatality"))
			{
				Float JumpVelZ = pb_jumpheight + ElevatorJumpBoost;
				Float JumpFac = GetPowerJump();
				if(JumpFac) { JumpVelZ *= JumpFac; }
				
				if(zm_rampjump) //Ramp Jumps
					Vel.Z += (Vel.Z > 0 ? zm_rjumpmulti : 1) * JumpVelZ;
				else
					Vel.Z = (- FloorNormal.XY dot SafeUnit2(Vel.XY) > 0 ? 1.f + sin(FloorAngle) : 1.f) * JumpVelZ; // - FloorNormal.XY dot SafeUnit2(Vel.XY) > 0 == going uphill on a slope
				
				bOnMobj = false;
				ZMJumpTics = True;
				
				if(!(player.cheats & CF_PREDICTING) && !JumpSoundCooler)
				{
					A_PlaySound("*jump", CHAN_BODY);
					JumpSoundCooler = 4;
				}
				
				//if autojump is off set BlockJump true until jump key is unpressed
				BlockJump = pb_autojump ? False : True;
				BlockDoubleJump = True;
			}
			else if(!Player.OnGround && CanDoubleJump && !BlockDoubleJump && ((pb_doublejump == 1 && Vel.Z > 0) || pb_doublejump == 2))
			{
				Float DoubleJumpVelZ = pb_jumpheight * pb_doublejumpheight;
				Float JumpFac = GetPowerJump();
				if(JumpFac) { DoubleJumpVelZ *= JumpFac; }
				Vel.Z = DoubleJumpVelZ;
				
				bOnMobj = false;
				ZMJumpTics = True;
				
				if(!(player.cheats & CF_PREDICTING)) { A_PlaySound("JMPBOOT", CHAN_BODY); }
				
				CanDoubleJump = False;
			}
		}
		else
		{
			BlockDoubleJump = False;
			BlockJump = False;
		}
	}
	
	void BuildGravity()
	{
		if(!bNOGRAVITY && !WaterLevel < 2 && !GrappleVel.Length())
			Gravity = pb_setgravity;
		else
			Gravity = 0.f;
	}
	
	void BuildJump()
	{
		let player = self.player;
		
		//Common stuff
		PreJumpCommon();
		
		//underwater/flying specific jump behavior are in WaterMove and FlyMove
		if(WaterLevel >= 2 || bNOGRAVITY) { return; }
		
		//Check slope angle and sector height
		Bool SlopedFloor;
		[BlockJump, SlopedFloor] = CheckIfJumpable();
		
		//Elevators Jump Boost
		ElevatorJump(SlopedFloor);
		
		////////////////////////////////
		//Actual Jump
		if(player.cmd.buttons & BT_JUMP || BuildJumpDelay)
		{
			//Special circumstances jump denial
			if(LedgeGrabbed || LandingVelZ >= 10.f || GrappleVel.Length() || CanWSlide) { return; }
			
			if(player.crouchoffset != 0)
			{
				player.crouching = 1;
			}
			else if(player.onground && !BlockJump)
			{
				Double BuildSmallerJump;
				
				if(player.deltaviewheight)
				{
					BuildSmallerJump = 0.85f;
				}
				else
				{
					BuildJumpDelay++;
					if(BuildJumpDelay == 1)
					{
						player.viewheight -= be_jumpanim;
						return;
					}
					else
					{
						BuildJumpDelay = 0;
						BuildSmallerJump = 1.f;
					}
				}
				
				Float JumpVelZ = pb_jumpheight + ElevatorJumpBoost;
				Float JumpFac = GetPowerJump();
				if(JumpFac) { JumpVelZ *= JumpFac; }
				
				if(zm_rampjump) //Ramp Jumps
					Vel.Z += (Vel.Z > 0 ? zm_rjumpmulti : 1) * JumpVelZ;
				else
					Vel.Z = (- FloorNormal.XY dot SafeUnit2(Vel.XY) > 0 ? 1.f + sin(FloorAngle) : 1.f) * JumpVelZ; // - FloorNormal.XY dot SafeUnit2(Vel.XY) > 0 == going uphill on a slope
					
				bOnMobj = false;
				ZMJumpTics = True;
					
				if(!(player.cheats & CF_PREDICTING) && !JumpSoundCooler)
				{
					A_PlaySound("*jump", CHAN_BODY);
					JumpSoundCooler = 4;
				}
				
				BlockJump = pb_autojump ? False : True;
				BlockDoubleJump = True;
			}
			else if(!Player.OnGround)
			{
				if(BuildJumpDelay) { BuildJumpDelay = 0; }
				
				if(CanDoubleJump && !BlockDoubleJump && ((pb_doublejump == 1 && Vel.Z > 0) || pb_doublejump == 2))
				{
					Float DoubleJumpVelZ = pb_jumpheight * pb_doublejumpheight;
					Float JumpFac = GetPowerJump();
					if(JumpFac) { DoubleJumpVelZ *= JumpFac; }
					Vel.Z = DoubleJumpVelZ;
					
					bOnMobj = false;
					ZMJumpTics = True;
					
					if(!(player.cheats & CF_PREDICTING)) { A_PlaySound("*jump", CHAN_BODY); }
					
					CanDoubleJump = False;
				}
			}
		}
		else
		{
			BlockDoubleJump = False;
			BlockJump = False;
		}
	}
	
	void PainkillerGravity()
	{
		if(WaterLevel >= 2)
		{
			if(Vel.Length() < MaxGroundSpeed / 3.f)
				Gravity = 0.5f;
			else
				Gravity = 0.f;
		}
		else if(bNOGRAVITY || GrappleVel.Length())
		{
			Gravity = 0.f;
		}
		else
		{
			Gravity = pb_setgravity;
		}
	}
	
	void PainkillerJump()
	{
		let player = self.player;
		
		//Common stuff
		PreJumpCommon();
		
		//underwater/flying specific jump behavior are in WaterMove and FlyMove
		if(WaterLevel >= 2 || bNOGRAVITY) { return; }
		
		//Check slope angle and sector height
		Bool SlopedFloor;
		[BlockJump, SlopedFloor] = CheckIfJumpable();
		
		//Elevators Jump Boost
		ElevatorJump(SlopedFloor);
		
		////////////////////////////////
		//Actual Jump
		if(player.cmd.buttons & BT_JUMP)
		{
			if(LedgeGrabbed || GrappleVel.Length() || CanWSlide) { return; }
			
			if(player.crouchoffset != 0)
			{
				player.crouching = 1;
			}
			else if(player.onground && !BlockJump)
			{
				SmallerJumpHeight++;
				
				Float JumpVelZ = pb_jumpheight + ElevatorJumpBoost;
				Float JumpFac = GetPowerJump();
				if(JumpFac) { JumpVelZ *= JumpFac; }
					
				if(zm_rampjump) //Ramp Jumps
				{
					Vel.Z += (SmallerJumpHeight > 1 ? JumpVelZ * pk_bhopjumpheight : JumpVelZ) * (Vel.Z > 0 ? zm_rjumpmulti : 1);
				}
				else
				{
					Float SlopeFactor = - FloorNormal.XY dot SafeUnit2(Vel.XY) > 0 ? 1.f + sin(FloorAngle) : 1.f;
					Vel.Z = (SmallerJumpHeight > 1 ? JumpVelZ * pk_bhopjumpheight : JumpVelZ) * SlopeFactor;
				}
				
				bOnMobj = false;
				ZMJumpTics = True;
				
				if(!(player.cheats & CF_PREDICTING) && !JumpSoundCooler)
				{
					A_PlaySound("*jump", CHAN_BODY);
					JumpSoundCooler = 4;
				}
				
				//if autojump is on set Blockjump false while jump key is pressed
				BlockJump = pb_autojump ? False : True;
				BlockDoubleJump = True;
			}
			else if(!Player.OnGround && CanDoubleJump && !BlockDoubleJump && ((pb_doublejump == 1 && Vel.Z > 0) || pb_doublejump == 2))
			{
				Float DoubleJumpVelZ = pb_jumpheight * pb_doublejumpheight;
				Float JumpFac = GetPowerJump();
				if(JumpFac) { DoubleJumpVelZ *= JumpFac; }
				Vel.Z = DoubleJumpVelZ;
				
				bOnMobj = false;
				ZMJumpTics = True;
				
				if(!(player.cheats & CF_PREDICTING)) { A_PlaySound("*jump", CHAN_BODY); }
				
				CanDoubleJump = False;
			}
		}
		else
		{
			BlockDoubleJump = False;
			BlockJump = False;
		}
	}
	
	void UTGravity()
	{
		//Gravity
		if(WaterLevel >= 2)
		{
			if(Vel.Length() < MaxGroundSpeed / 3.f && !(player.cmd.buttons & BT_JUMP))
				Gravity = 0.5f;
			else
				Gravity = 0.f;
		}
		else if(bNOGRAVITY || GrappleVel.Length())
		{
			Gravity = 0.f;
		}
		else
		{
			Gravity = pb_setgravity;
		}
	}
	
	void UTJump()
	{
		let player = self.player;
		
		//Common stuff
		PreJumpCommon();
		
		//underwater/flying specific jump behavior are in WaterMove and FlyMove
		if(WaterLevel >= 2 || bNOGRAVITY) { return; }
		
		//Check slope angle and sector height
		Bool SlopedFloor;
		[BlockJump, SlopedFloor] = CheckIfJumpable();
		
		//Elevators Jump Boost
		ElevatorJump(SlopedFloor);
		
		////////////////////////////////
		//Actual Jump
		if(player.cmd.buttons & BT_JUMP)
		{
			//Special circumstances jump denial
			if(LedgeGrabbed || GrappleVel.Length() || CanWSlide || (DashCooler && DashCooler < 100)) { return; }
			
			if(player.crouchoffset != 0)
			{
				player.crouching = 1;
			}
			else if(Player.OnGround && !BlockJump)
			{
				Float JumpVelZ = pb_jumpheight + ElevatorJumpBoost;
				Float JumpFac = GetPowerJump();
				if(JumpFac) { JumpVelZ *= JumpFac; }
				
				if(zm_rampjump) //Ramp Jumps
					Vel.Z += (Vel.Z > 0 ? zm_rjumpmulti : 1) * JumpVelZ;
				else
					Vel.Z = (- FloorNormal.XY dot SafeUnit2(Vel.XY) > 0 ? 1.f + sin(FloorAngle) : 1.f) * JumpVelZ; // - FloorNormal.XY dot SafeUnit2(Vel.XY) > 0 == going uphill on a slope
				
				bOnMobj = false;
				ZMJumpTics = True;
				
				if(!(player.cheats & CF_PREDICTING) && !JumpSoundCooler)
				{
					A_PlaySound("*jump", CHAN_BODY);
					JumpSoundCooler = 4;
				}
				
				//if autojump is on set Blockjump false while jump key is pressed
				BlockJump = pb_autojump ? False : True;
				BlockDoubleJump = True;
			}
			else if(!Player.OnGround && pb_doublejump && CanDoubleJump && !BlockDoubleJump && Vel.Z > 0)
			{
				Float DoubleJumpVelZ = pb_jumpheight * pb_doublejumpheight;
				Float JumpFac = GetPowerJump();
				if(JumpFac) { DoubleJumpVelZ *= JumpFac; }
				Vel.Z = DoubleJumpVelZ;
				
				bOnMobj = false;
				ZMJumpTics = True;
				
				if(!(player.cheats & CF_PREDICTING)) { A_PlaySound("*jump", CHAN_BODY); }
				
				CanDoubleJump = False;
			}
		}
		else
		{
			BlockDoubleJump = False;
			if(Player.OnGround) { BlockJump = False; }
		}
	}
	
	//////////////////////////////////////////
	// Ground Movement						//
	//////////////////////////////////////////
	
	float ZMScale()
	{
		Let Player = self.Player;
		UserCmd cmd = player.cmd;
		
		Bool 	IsWalking = (CVar.GetCVar("cl_run", Player).GetBool() && (cmd.buttons & BT_SPEED)) || (!CVar.GetCVar("cl_run", Player).GetBool() && !(cmd.buttons & BT_SPEED));
		Float 	MoveMulti;
		
		if(cmd.sidemove || cmd.forwardmove)
		{
			if(Player.CrouchFactor == 0.5)
				MoveMulti = min(zm_crouchspeed, pb_walkspeed);
			else if(IsWalking)
				MoveMulti = pb_walkspeed;
			else
				MoveMulti = 1;
		}
		else
		{
			MoveMulti = 1; //to fix a bobbing issue
		}
		
		return MoveMulti;
	}
	
	float GroundSpeedMulti(bool SpeedOrAccel)
	{
		return (SpeedOrAccel ? ZMoveFactor : ActualSpeed) * (Straferunning ? pb_strafemodifier : 1);
	}
	
	void DropPrevention()
	{
		let player = self.player;
		UserCmd cmd = Player.cmd;
		
		Bool GuardRail = ((!cmd.sidemove && !cmd.forwardmove && Vel.XY.Length()) ||
						 (CVar.GetCVar("cl_run", Player).GetBool() && (cmd.buttons & BT_SPEED)) || (!CVar.GetCVar("cl_run", Player).GetBool() && !(cmd.buttons & BT_SPEED))) //fuck me having to do this
						 && Player.OnGround && !Pain;
		
		if(GuardRail)
		{
			Float GuardAngle = VectorAngle(Vel.X, Vel.Y);
			Float GuardX = Pos.X + Radius * cos(GuardAngle);
			Float GuardY = Pos.Y + Radius * sin(GuardAngle);
			Bool FallDanger = Pos.Z - GetZAt(GuardX, GuardY, 0, GZF_ABSOLUTEPOS|GZF_ABSOLUTEANG) > Height;
			if(FallDanger) { Vel.XY *= 0.5f; }
		}
	}
	
	void GroundSpriteAnimation()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		if(Player.Cheats & CF_PREDICTING == 0 && Vel.XY.Length() > 1.f && (cmd.forwardmove || cmd.sidemove))
			PlayRunning();
		else
			PlayIdle();
			
		AnimateJump = 6;
	}
	
	void AirSpriteAnimation()
	{
		if(AnimateJump)
		{
			PlayRunning();
			AnimateJump--;
		}
		else
		{
			PlayIdle();
		}
	}
	
	//////////////////////////////////////////
	// Doom
	
	void DoomHandleMove()
	{
		MaxGroundSpeed *= GroundSpeedMulti(True);
		
		if(!Player.OnGround || (Player.OnGround && DashNumber))
		{
			DoomAirMove();
			if(pb_ledgegrab) { LedgeGrabInitiator(); }
			if(!Player.OnGround && DashNumber) { DashCooler = 100; }
		}
		else
		{
			DoomGroundMove();
			Grappled = False;
			if(pb_dropprevention) { DropPrevention(); }
		}
	}
	
	void DFriction()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		//Going too slow, stop
		if(WaterLevel >= 2 || bNOGRAVITY)
		{
			if(Vel.Length() < 1.f && !cmd.sidemove && !cmd.forwardmove)
			{
				Vel.XY = (0, 0);
				return;
			}
		}
		else if(Vel.XY.Length() < 1.f && !cmd.sidemove && !cmd.forwardmove)
		{
			Vel.XY = (0, 0);
			return;
		}
		
		//Balance friction with inputs strength
		if(WaterLevel >= 2)
		{
			Acceleration3 *= 4.f;
			Vel *= 0.6f;
		}
		else if(bNOGRAVITY)
		{
			Vel *= 0.9f;
		}
		else
		{
			Acceleration *= pb_friction;
			Vel.XY *= 1 - pb_friction / 10.f;
		}
	}
	
	void DoomGroundMove()
	{
		let player = self.player;
		UserCmd cmd = player.cmd;
		
		///////////////////////////////////////////
		//Actual Movement
		
		//Directional inputs
		Acceleration = RotateVector((cmd.forwardmove, -cmd.sidemove), Angle);
		Acceleration = (MaxGroundSpeed / 10.f) * SafeUnit2(Acceleration);
		
		//Friction
		DFriction();
		
		//Acceleration
		Vel.XY += Acceleration;
		
		// Sprite Animation
		GroundSpriteAnimation();
	}
	
	void DoomAirMove()
	{
		let player = self.player;
		UserCmd cmd = player.cmd;
		
		Bool DashMove;
		if((DashNumber || Grappled) && MaxAirSpeed > MaxGroundSpeed) { DashMove = True; }
		
		///////////////////////////////////////////
		//Actual Movement
		
		//Directional inputs
		Acceleration = RotateVector((cmd.forwardmove, -cmd.sidemove), Angle);
		Acceleration = (MaxGroundSpeed / 20.f) * SafeUnit2(Acceleration);
		
		//Acceleration
		Vel.XY += Acceleration;
		
		//Limiter
		Vel.XY = min(Vel.XY.Length(), DashMove ? MaxAirSpeed : MaxGroundSpeed) * SafeUnit2(Vel.XY);
		
		//Sprite Animation
		AirSpriteAnimation();
	}
	
	void WaterVelZLimiter()
	{
		//Avoids dolphin jumping out of water
		Vel.Z = min(6.f, Vel.Z);
		if(Pitch < 0) { Acceleration3.Z = 0; }
	}
	
	void DoomWaterMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		//Value Resets
		MaxAirSpeed = Vel.XY.Length();
		
		///////////////////////////////////////////
		//Actual Movement
		
		//Directional inputs
		Acceleration3 = (cmd.forwardmove, -cmd.sidemove, 0);
		//XY
		Acceleration3.XY = (MaxGroundSpeed / 20.f) * SafeUnit2(Acceleration3.XY);
		//Z
		if(cmd.buttons & BT_JUMP || cmd.buttons & BT_CROUCH)
		{
			Acceleration3.Z = (cmd.buttons & BT_JUMP ? 1 : -1) * (MaxGroundSpeed / 20.f) * ActualSpeed;
		}
		else
		{
			Acceleration3.Z = Acceleration3.X * sin(-Pitch);
			Acceleration3.X *= cos(Pitch);
		}
		
		//Friction
		DFriction();
		if(WaterLevel == 2) { WaterVelZLimiter(); }
		
		//Acceleration
		Vel += (RotateVector(Acceleration3.XY, Angle), Acceleration3.Z);
		
		//Sprite Animation
		GroundSpriteAnimation();
	}
	
	void DoomFlyMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		//Value Resets
		MaxAirSpeed = Vel.XY.Length();
		
		///////////////////////////////////////////
		//Actual Movement
		
		//Directional inputs
		Acceleration3 = (cmd.forwardmove, -cmd.sidemove, 0);
		//XY
		if(Acceleration3.Length()) { Acceleration3.XY = (MaxGroundSpeed * 3.f / 20.f) * SafeUnit2(Acceleration3.XY); }
		//Z
		if(cmd.buttons & BT_JUMP || cmd.buttons & BT_CROUCH)
		{
			Acceleration3.Z = (cmd.buttons & BT_JUMP ? 1 : -1) * (MaxGroundSpeed * 3.f / 20.f) * ActualSpeed;
		}
		else
		{
			Acceleration3.Z = Acceleration3.X * sin(-Pitch);
			Acceleration3.X *= cos(Pitch);
		}
		
		//Friction
		DFriction();
		
		//Acceleration
		Vel += (RotateVector(Acceleration3.XY, Angle), Acceleration3.Z);
		
		//Limiter
		Vel = min(Vel.Length(), (MaxGroundSpeed * 3.f) / 2.f) * SafeUnit3(Vel);
		
		//Sprite Animatiom
		PlayIdle();
	}
	
	//////////////////////////////////////////
	// Build Engine
	
	void BuildHandleMove()
	{
		MaxGroundSpeed *= GroundSpeedMulti(True);
		
		if(!Player.OnGround || (Player.OnGround && DashNumber))
		{
			BuildAirMove();
			if(pb_ledgegrab) { LedgeGrabInitiator(); }
			if(!Player.OnGround && DashNumber) { DashCooler = 100; }
		}
		else
		{
			BuildGroundMove();
			Grappled = False;
			if(pb_dropprevention) { DropPrevention(); }
		}
	}
	
	void BuildInputDetection()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		if(cmd.sidemove)
		{
			if(cmd.buttons & BT_MOVERIGHT)
				SVel += 40;
			else
				SVel -= 40;
				
			SVel = clamp(SVel, -90, 90);
		}
		else
		{
			SVel = 0;
		}
		
		if(cmd.forwardmove)
		{
			if(cmd.buttons & BT_FORWARD)
				FVel += 40;
			else
				FVel -= 40;
				
			FVel = clamp(FVel, -90, 90);
		}
		else
		{
			FVel = 0;
		}
		
		//Only for flying and swimming
		if(WaterLevel == 2 && DeepWater)
		{
			if(cmd.buttons & BT_JUMP)
			{
				if(Vel.Z > 0) { Vel.Z = 0.f; }
				UVel = 0;
				return;
			}
			else
			{
				DeepWater = False;
			}
		}
		
		if(bNOGRAVITY || WaterLevel >= 2)
		{
			if(cmd.buttons & BT_JUMP)
				UVel += 40;
			else if(cmd.buttons & BT_CROUCH)
				UVel -= 40;
			else
				UVel = 0;
				
			UVel = clamp(UVel, -90, 90);
		}
		else
		{
			UVel = 0;
		}
	}
	
	int BuildFriction()
	{
		//Friction Value
		Int Friction;
		if(WaterLevel >= 2)
			Friction = - 0x2000;
		else if(bNOGRAVITY)
			Friction = 0;
		else
			Friction = (8 - pb_friction) * 2 * 0x0200;
		
		//Applying the friction on the length of the vector instead of the single components fixed the Build engine directional distortion
		Int FrictionedVel = Int((!bNOGRAVITY && WaterLevel < 2 ? Vel.XY.Length() : Vel.Length()) * (0xCFD0 + Friction)) >> 16;
		
		return FrictionedVel <= 10.f ? 0 : FrictionedVel;
	}
	
	void BuildGroundMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		//Values Reset
		MaxAirSpeed = Vel.XY.Length();
		
		///////////////////////////////////////////
		//Actual Movement
		
		//Convert Velocity in Build Units
		Vel.XY *= 20.f;
		
		if(LandingVelZ < 10.f) //this value feels good
		{
			//Directional inputs
			BuildInputDetection();
			Acceleration = RotateVector((FVel, - SVel), Angle);
			if(Acceleration.Length()) { Acceleration = min(Acceleration.Length(), 90) * SafeUnit2(Acceleration) * GroundSpeedMulti(False); }
			
			//Acceleration
			Vel.XY += Acceleration;
		}
		else //landing recovery
		{
			LandingVelZ--;
		}
		
		//Friction
		Int FrictionedVel = BuildFriction();
		
		//Translate back into Doom Units
		Vel.XY /= 20.f;
		FrictionedVel /= 20.f;
		
		//Limiter
		Vel.XY = min(FrictionedVel, MaxGroundSpeed) * SafeUnit2(Vel.XY);
		
		//Sprite Animation
		GroundSpriteAnimation();
	}
	
	void BuildAirMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		Bool DashMove;
		if((DashNumber || Grappled) && MaxAirSpeed > MaxGroundSpeed) { DashMove = True; }
		
		///////////////////////////////////////////
		//Actual Movement
		
		//Convert Velocity in Build Units
		Vel.XY *= 20.f;
		
		//Directional inputs
		BuildInputDetection();
		Acceleration = RotateVector((FVel, - SVel), Angle);
		Acceleration = min(Acceleration.Length(), 90) * SafeUnit2(Acceleration) * GroundSpeedMulti(False);
		
		//Acceleration
		Vel.XY += Acceleration;
		
		//Friction
		Int FrictionedVel;
		if(!DashMove)
			FrictionedVel = BuildFriction();
		else
			FrictionedVel = Vel.XY.Length();
		
		//Limiter
		Vel.XY = min(FrictionedVel, (DashMove ? MaxAirSpeed : MaxGroundSpeed) * 20) * SafeUnit2(Vel.XY);
		
		//Translate back into Doom Units
		Vel.XY /= 20.f;
		
		//Sprite Animation
		AirSpriteAnimation();
		
		//Reset speed cap
		if(Vel.XY.Length() <= MaxGroundSpeed) { MaxAirSpeed = Vel.XY.Length(); }
	}
	
	void BuildWaterMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		//Value Resets
		MaxAirSpeed = Vel.XY.Length();
		if(WaterLevel == 3) { DeepWater = True; }
		
		///////////////////////////////////////////
		//Actual Movement
		
		//Convert Velocity in Build Units
		Vel *= 20.f;
		
		//Directional inputs
		BuildInputDetection();
		Acceleration = RotateVector((FVel, - SVel), Angle);
		Acceleration = min(Acceleration.Length(), 90) * SafeUnit2(Acceleration) * GroundSpeedMulti(False);
		
		//Acceleration
		Vel.XY += Acceleration;
		
		//Crouch/jump press
		Vel.Z += UVel;
		
		//Friction
		Int FrictionedVel = BuildFriction();
		
		//Limiter
		Vel = min(FrictionedVel, MaxGroundSpeed * 15.f) * SafeUnit3(Vel);
		if(Deepwater && WaterLevel == 2 && Vel.Z > 0) { Vel.Z = 0; }
		
		//Translate back into Doom Units
		Vel /= 20.f;
		
		// Sprite Animation
		GroundSpriteAnimation();
	}
	
	void BuildFlyMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		//Value Resets
		MaxAirSpeed = Vel.XY.Length();
		
		///////////////////////////////////////////
		//Actual Movement
		
		//Convert Velocity in Build Units
		Vel *= 20.f;
		
		//Directional inputs
		BuildInputDetection();
		Acceleration = RotateVector((FVel, - SVel), Angle);
		Acceleration = min(Acceleration.Length(), 90) * SafeUnit2(Acceleration) * GroundSpeedMulti(False);
		
		//Acceleration
		Vel.XY += Acceleration;
		
		//Crouch/jump press
		Vel.Z += UVel;
		
		//Friction
		Int FrictionedVel = BuildFriction();
		
		//Limiter
		Vel = min(FrictionedVel, MaxGroundSpeed * 30.f) * SafeUnit3(Vel);
		
		//Translate back into Doom Units
		Vel /= 20.f;
		
		// Sprite Animatiom
		PlayIdle();
	}
	
	//////////////////////////////////////////
	// Dusk
	
	void DuskHandleMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		if(!Player.OnGround || (Player.OnGround && (((cmd.buttons & BT_JUMP) && !BlockJump) || DashNumber)))
		{
			DuskAirMove();
			if(pb_ledgegrab) { LedgeGrabInitiator(); }
			if(!Player.OnGround && DashNumber) { DashCooler = 100; }
		}
		else
		{
			MaxGroundSpeed *= GroundSpeedMulti(True);
			DuskGroundMove();
			Grappled = False;
			if(pb_dropprevention) { DropPrevention(); }
		}
	}
	
	void DuskGroundMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		//Values Reset
		MaxAirSpeed = MaxGroundSpeed;
		
		///////////////////////////////////////////
		//Actual Movement
		
		//Directional inputs
		Acceleration = RotateVector((cmd.forwardmove, -cmd.sidemove), Angle);
		Acceleration = (MaxGroundSpeed / 10.f) * SafeUnit2(Acceleration);
		
		//Friction
		DFriction();
		
		//Acceleration
		Vel.XY += Acceleration;
		
		//Sprite Animation
		GroundSpriteAnimation();
	}
	
	void DuskAirMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		Bool CanAccelerate = ((cmd.buttons & BT_MOVERIGHT) && !(cmd.buttons & BT_MOVELEFT)) || (!(cmd.buttons & BT_MOVERIGHT) && (cmd.buttons & BT_MOVELEFT));
		
		///////////////////////////////////////////
		//Actual Movement
		
		//Top Speed Penalty
		if(!CanAccelerate && Player.OnGround) { MaxAirSpeed = max(MaxAirSpeed - dsk_acceleration * ActualSpeed / 2.f, MaxGroundSpeed); }
		
		//Directional inputs
		Acceleration = RotateVector((cmd.forwardmove, - cmd.sidemove), Angle);
		if(Acceleration.Length())
		{
			Acceleration = MaxAirSpeed * SafeUnit2(Acceleration) / 3.f; //multiplying by Vel / 10.f mantains air control consistent at all speed
			
			//Top Speed
			if(!ADashTargetSpeed)
			{
				if(Player.OnGround && CanAccelerate) { MaxAirSpeed += dsk_acceleration * ActualSpeed; }
				MaxAirSpeed = clamp(MaxAirSpeed, MaxGroundSpeed, pb_maxhopspeed);
			}
		}
		
		//Friction
		if(Vel.XY.Length() < 1.f)
			Vel.XY = (0, 0);
		else
			Vel.XY *= 0.8f;
		
		//Acceleration
		Vel.XY += Acceleration;
		
		//Limiter
		Vel.XY = min(Vel.XY.Length(), MaxAirSpeed) * SafeUnit2(Vel.XY);
		
		//Sprite Animation
		AirSpriteAnimation();
	}
	
	void DuskWaterMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		//Value Resets
		MaxAirSpeed = Vel.XY.Length();
		
		///////////////////////////////////////////
		//Actual Movement
		
		//Directional Inputs
		Acceleration3 = (cmd.forwardmove, - cmd.sidemove, 0);
		if(cmd.buttons & BT_JUMP || cmd.buttons & BT_CROUCH)
		{
			Acceleration3.XY = (0, 0);
			Acceleration3.Z = (cmd.buttons & BT_CROUCH ? -1 : 1) * (MaxGroundSpeed * 3.f / 40.f) * ActualSpeed;
		}
		else
		{
			Acceleration3.XY = (MaxGroundSpeed * 3.f / 40.f) * SafeUnit2(Acceleration3.XY);
			Acceleration3.Z = Acceleration3.X * sin(-Pitch);
			Acceleration3.X *= cos(Pitch);
		}
		
		//Friction
		DFriction();
		if(WaterLevel == 2) { WaterVelZLimiter(); }
		
		//Acceleration
		Vel += (RotateVector(Acceleration3.XY, Angle), Acceleration3.Z);
		
		//Sprite Animation
		GroundSpriteAnimation();
	}
	
	void DuskFlyMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		//Value Resets
		MaxAirSpeed = Vel.XY.Length();
		
		///////////////////////////////////////////
		//Actual Movement
		
		//Directional Inputs
		Acceleration3 = (cmd.forwardmove, - cmd.sidemove, 0);
		if(cmd.buttons & BT_JUMP || cmd.buttons & BT_CROUCH)
		{
			Acceleration3.XY = (0, 0);
			Acceleration3.Z = (cmd.buttons & BT_CROUCH ? -1 : 1) * (MaxGroundSpeed * 3.f / 20.f) * ActualSpeed;
		}
		else
		{
			Acceleration3.XY = (MaxGroundSpeed * 3.f / 20.f) * SafeUnit2(Acceleration3.XY);
			Acceleration3.Z = Acceleration3.X * sin(-Pitch);
			Acceleration3.X *= cos(Pitch);
		}
		
		//Friction
		DFriction();
		
		//Acceleration
		Vel += (RotateVector(Acceleration3.XY, Angle), Acceleration3.Z);
		
		//Sprite Animatiom
		PlayIdle();
	}
	
	//////////////////////////////////////////
	// Painkiller
	
	void PainkillerHandleMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		if(!Player.OnGround || (Player.OnGround && (((cmd.buttons & BT_JUMP) && !BlockJump) || DashNumber)))
		{
			PainkillerAirMove();
			if(pb_ledgegrab) { LedgeGrabInitiator(); }
			if(!Player.OnGround && DashNumber) { DashCooler = 100; }
		}
		else
		{
			MaxGroundSpeed *= GroundSpeedMulti(True);
			PainkillerGroundMove();
			Grappled = False;
			if(pb_dropprevention) { DropPrevention(); }
		}
	}
	
	void PainkillerFriction()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		//Going too slow, stop
		if(WaterLevel >= 2 || bNOGRAVITY)
		{
			if(Vel.Length() < 1.f)
			{
				Vel.XY = (0, 0);
				return;
			}
		}
		else if(Vel.XY.Length() < 1.f)
		{
			Vel.XY = (0, 0);
			return;
		}
		
		Float Friction; //I modded PK to print to console the length of the velocity vector and it increased and decreased by a fixed value
		if(WaterLevel >= 2 || bNOGRAVITY)
		{
			Friction = MaxGroundSpeed / (WaterLevel >= 2 ? 2.f : 10.f);
			
			if(Vel.Length() >= Friction)
				Vel -= Friction * SafeUnit3(Vel);
			else if(Vel.Length())
				Vel -= Vel.Length() * SafeUnit3(Vel);
		}
		else
		{
			Friction = MaxGroundSpeed / (12.f - pb_friction);
			
			if(Vel.XY.Length() >= Friction)
				Vel.XY -= Friction * SafeUnit2(Vel.XY);
			else if(Vel.XY.Length())
				Vel.XY -= Vel.XY.Length() * SafeUnit2(Vel.XY);
		}
	}
	
	void PainkillerValuesReset()
	{
		MaxAirSpeed = ActualMaxAirSpeed = max(Vel.XY.Length(), MaxGroundSpeed / 4.f);
		SmallerJumpHeight = TrickFailed = 0;
		AirControl = 1;
	}
	
	void PainkillerGroundMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		//Values Reset
		PainkillerValuesReset();
		
		///////////////////////////////////////////
		//Actual Movement
		
		//Directional inputs
		Acceleration = (cmd.forwardmove, - cmd.sidemove);
		Acceleration = MaxGroundSpeed * 0.6f * SafeUnit2(Acceleration);
		
		//Friction
		PainkillerFriction();
		
		//Acceleration
		Vel.XY += RotateVector(Acceleration, Angle);
		
		//Limiter
		Vel.XY = min(Vel.XY.Length(), MaxGroundSpeed) * SafeUnit2(Vel.XY);
		
		//Sprite Animation
		GroundSpriteAnimation();
	}
	
	void PainkillerAirMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		Vector2 DirInput = SafeUnit2((cmd.forwardmove, - cmd.sidemove));
		ActualMaxAirSpeed = Vel.XY.Length(); //if speed is forcefully lowered due to impact with walls or actors we need to get along with that. Not lowering going up stairs
		
		if(!TrickFailed)
		{
			//Air Control
			AirControlCheck(DirInput.Length());
			//Trickjump check
			if(DirInput.Length()) { TrickJumpCheck(DirInput); }
		}
		
		if(Player.OnGround) //ground hop
		{
			if(TrickFailed) //Trick jump failed
			{
				Acceleration = MaxAirSpeed * DirInput;
				MaxAirSpeed = MaxGroundSpeed / 2.f; //penalty
				Vel.XY = RotateVector(Acceleration, Angle); //redirect movement in the pressed direction before applying the uber low air control
				AirControl = 0.01f;
				TrickFailed = False;
			}
			else if(AirControl == 1) //regular movement
			{
				//Directional inputs
				Acceleration = MaxAirSpeed * DirInput;
				
				//Top Speed
				if(Player.CrouchFactor == 1) { MaxAirSpeed = clamp(Vel.XY.Length() + pk_acceleration * ActualSpeed, MaxGroundSpeed, pb_maxhopspeed); } //no cheap speed up coming out of QSlide
				ActualMaxAirSpeed = MaxAirSpeed;
			}
			else
			{
				//Top Speed
				MaxAirSpeed = clamp(Vel.XY.Length() - pk_acceleration * ActualSpeed, MaxGroundSpeed, pb_maxhopspeed);
			}
			
			//Acceleration
			Vel.XY += RotateVector(Acceleration, Angle) * AirControl;
			
			//Limiter
			Vel.XY = min(Vel.XY.Length(), MaxAirSpeed) * SafeUnit2(Vel.XY);
		}
		else //mid air
		{
			if(TrickFailed) //Trick jump failed
			{
				PainkillerFriction();
			}
			else //regular movement
			{
				//Acceleration
				Vel.XY += RotateVector(Acceleration, Angle) * AirControl;
				
				//Top speed penality
				TopSpeedPenality();
				
				//Limiter
				Vel.XY = min(Vel.XY.Length(), ActualMaxAirSpeed) * SafeUnit2(Vel.XY);
			}
		}
		
		//Sprite Animation
		AirSpriteAnimation();
	}
	
	void AirControlCheck(Bool DirInput)
	{
		Let Player = Self.Player;
		
		if(!DirInput || Pain)
		{
			AirControl = 0.01f;
			if(!DirInput && Vel.XY.Length() <= 1.f)
			{
				Acceleration = (0, 0);
				Vel.XY = (0, 0);
			}
		}
		else
		{
			AirControl = 1;
		}
	}
	
	void TrickJumpCheck(Vector2 DirInput)
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		Bool BadTrick = SafeUnit2(Acceleration) dot DirInput <= 0;
		
		if(abs(RealFloorZ - Pos.Z) > 16)
		{
			if(BadTrick)
				TrickFailed = True;
			else
				TrickJumpAngle = Angle;
		}
		else
		{
			if(BadTrick && abs(Angle - TrickJumpAngle) < 90) { TrickFailed = True; }
		}
	}
	
	void TopSpeedPenality()
	{
		Let Player = Self.Player;
		
		//Directional change top speed penalty
		Float AbsViewAngleDelta = abs(ViewAngleDelta);									//In Painkiller speed punishment
		if(AbsViewAngleDelta >= 3.f)													//is 5 times the angle variation,		
			ActualMaxAirSpeed -= AbsViewAngleDelta * 0.01f; //this feels good			//although in that engine view angle
		else																			//is 0 to pi for real world 0 to 180,
			ActualMaxAirSpeed += 0.2f; //this too										//and -pi to 0 for 180 to 360.
		
		ActualMaxAirSpeed = clamp(ActualMaxAirSpeed, MaxGroundSpeed, MaxAirSpeed);		//This is an as close as possible imitation
	}
	
	void PainkillerWaterMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		//Value Resets
		PainkillerValuesReset();
		
		///////////////////////////////////////////
		//Actual Movement
		
		//Directional inputs
		Acceleration3 = (cmd.forwardmove, -cmd.sidemove, 0);
		//XY
		Acceleration3.XY = (MaxGroundSpeed / 2.f) * SafeUnit2(Acceleration3.XY);
		//Z
		if(cmd.buttons & BT_JUMP || cmd.buttons & BT_CROUCH)
		{
			Acceleration3.Z = (cmd.buttons & BT_JUMP ? 1 : -1) * 30.f * ActualSpeed;
		}
		else
		{
			Acceleration3.Z = Acceleration3.X * sin(-Pitch);
			Acceleration3.X *= cos(Pitch);
		}
		
		//Friction
		PainkillerFriction();
		
		//Acceleration
		Vel += (RotateVector(Acceleration3.XY, Angle), Acceleration3.Z);
		
		//Limiter
		Vel = min(Vel.Length(), MaxGroundSpeed / 2.f) * SafeUnit3(Vel);
		
		//Sprite Animation
		GroundSpriteAnimation();
		
		//Set acceleration for when you stop swimming
		Acceleration = 30.f * SafeUnit2(Acceleration3.XY);
	}
	
	void PainkillerFlyMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		//Value Resets
		PainkillerValuesReset();
		
		///////////////////////////////////////////
		//Actual Movement
		
		//Directional inputs
		Acceleration3 = (cmd.forwardmove, -cmd.sidemove, 0);
		//XY
		Acceleration3.XY = (MaxGroundSpeed * 3.f) / 2.f * SafeUnit2(Acceleration3.XY);
		//Z
		if(cmd.buttons & BT_JUMP || cmd.buttons & BT_CROUCH)
		{
			Acceleration3.Z = (cmd.buttons & BT_JUMP ? 1 : -1) * 30.f * ActualSpeed;
		}
		else
		{
			Acceleration3.Z = Acceleration3.X * sin(-Pitch);
			Acceleration3.X *= cos(Pitch);
		}
		
		//Friction
		PainkillerFriction();
		
		//Acceleration
		Vel += (RotateVector(Acceleration3.XY, Angle), Acceleration3.Z);
		
		//Limiter
		Vel = min(Vel.Length(), (MaxGroundSpeed * 3.f) / 2.f) * SafeUnit3(Vel);
		
		//Sprite Animatiom
		PlayIdle();
		
		//Set acceleration for when the flight ends
		Acceleration = 30.f * SafeUnit2(Acceleration3.XY);
	}
	
	//////////////////////////////////////////
	// Quake
	
	void QuakeHandleMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		if(!Player.OnGround || (Player.OnGround && (((cmd.buttons & BT_JUMP) && !BlockJump) || DashNumber)))
		{
			QuakeAirMove();
			if(pb_ledgegrab) { LedgeGrabInitiator(); }
			if(!Player.OnGround && DashNumber) { DashCooler = 100; }
		}
		else
		{
			MaxGroundSpeed *= GroundSpeedMulti(True);
			QuakeGroundMove();
			Grappled = False;
			if(pb_dropprevention) { DropPrevention(); }
		}
	}
	
	void QuakeFriction(float StopSpeed, float Friction)
	{
		//Going too slow, stop
		if(WaterLevel >= 2 || bNOGRAVITY)
		{
			if(Vel.Length() < 0.5f)
			{
				Vel.XY = (0, 0);
				return;
			}
		}
		else if(Vel.XY.Length() < 1.f)
		{
			Vel.XY = (0, 0);
			return;
		}
		
		Double Velocity = Vel.Length();
		Double Drop, Control;
		if(WaterLevel >= 2)
		{
			drop = Velocity * Friction / TICRATE; //very tight friction
		}
		else if(bNOGRAVITY)
		{
			drop = Velocity * Friction / TICRATE; //loose friction
		}
		else if(Player.OnGround)
		{
			if(!Pain)
			{
				Control = Velocity < StopSpeed ? pb_friction : Velocity;
				Drop = Control * Friction / TICRATE;
			}
		}
		
		Double NewVelocity = (Velocity - Drop <= 0 ? 0 : Velocity - Drop) / (Velocity ? Velocity : 1.f); //I have no idea how sometimes a 0 value velocity makes it through so I have to do this
		if(WaterLevel >= 2 || bNOGRAVITY)
			Vel *= NewVelocity;
		else
			Vel.XY *= NewVelocity;
	}
	
	void QuakeAcceleration(Vector3 WishDir, Float WishSpeed, Float Accel)
	{
		Float CurrentSpeed = WishDir dot Vel;
		Float AddSpeed = WishSpeed - CurrentSpeed;
		if(AddSpeed <= 0) { return; }
		
		Float AccelerationSpeed = min(Accel * WishSpeed / TICRATE, AddSpeed);
		Vel += AccelerationSpeed * WishDir;
	}
	
	void QuakeGroundMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		//Values Reset
		MaxAirSpeed = Vel.XY.Length();
		
		///////////////////////////////////////////
		//Actual Movement
		
		//Directional inputs
		Acceleration = RotateVector((cmd.forwardmove, - cmd.sidemove), Angle);
		
		//Friction
		QuakeFriction(MaxGroundSpeed, 6.f);
	
		//Acceleration
		QuakeAcceleration((SafeUnit2(Acceleration), 0), MaxGroundSpeed, Pain ? 1.f : 10.f);
		
		//Sprite Animation
		GroundSpriteAnimation();
	}
	
	void QuakeAirMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		//Directional inputs
		Acceleration = RotateVector((cmd.forwardmove, - cmd.sidemove), Angle);
		
		//Acceleration
		if(!ADashTargetSpeed)
		{
			if(!q_strafetype)
			{
				QuakeAcceleration((SafeUnit2(Acceleration), 0), MaxGroundSpeed, q_3airaccel);
			}
			else if(q_strafetype == 1)
			{
				QuakeAcceleration((SafeUnit2(Acceleration), 0), q_1airaccel, 106.f);
			}
			else
			{
				if(cmd.sidemove && !cmd.forwardmove)
					QuakeAcceleration((SafeUnit2(Acceleration), 0), q_1airaccel, 106.f);
				else
					QuakeAcceleration((SafeUnit2(Acceleration), 0), MaxGroundSpeed, q_3airaccel);
			}
			
			//Limiter
			Vel.XY = min(Vel.XY.Length(), pb_maxhopspeed) * SafeUnit2(Vel.XY);
		}
		
		//Sprite Animation
		AirSpriteAnimation();
	}
	
	void QuakeWaterMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		//Value Resets
		MaxAirSpeed = Vel.XY.Length();
		
		///////////////////////////////////////////
		//Actual Movement
		
		//Directional inputs
		Acceleration3 = (cmd.forwardmove, -cmd.sidemove, 0);
		//XY
		Acceleration3.XY = SafeUnit2(Acceleration3.XY);
		//Z
		if(cmd.buttons & BT_JUMP || cmd.buttons & BT_CROUCH)
		{
			Acceleration3.Z = (cmd.buttons & BT_JUMP ? 1 : -1);
		}
		else
		{
			Acceleration3.Z = Acceleration3.X * sin(-Pitch);
			Acceleration3.X *= cos(Pitch);
		}
		
		//Friction
		QuakeFriction(0, 2.f);
		
		//Acceleration
		Acceleration3 = (RotateVector(Acceleration3.XY, Angle), Acceleration3.Z);
		QuakeAcceleration(SafeUnit3(Acceleration3), (MaxGroundSpeed * 3.f) / 5.f, 4.f);
		
		//Sprite Animation
		GroundSpriteAnimation();
	}
	
	void QuakeFlyMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		//Value Resets
		MaxAirSpeed = Vel.XY.Length();
		
		///////////////////////////////////////////
		//Actual Movement
		
		//Directional inputs
		Acceleration3 = (cmd.forwardmove, -cmd.sidemove, 0);
		//XY
		Acceleration3.XY = SafeUnit2(Acceleration3.XY);
		//Z
		if(cmd.buttons & BT_JUMP || cmd.buttons & BT_CROUCH)
		{
			Acceleration3.Z = (cmd.buttons & BT_JUMP ? 1 : -1);
		}
		else
		{
			Acceleration3.Z = Acceleration3.X * sin(-Pitch);
			Acceleration3.X *= cos(Pitch);
		}
		
		//Friction
		QuakeFriction(0, 3.f);
		
		//Acceleration
		Acceleration3 = (RotateVector(Acceleration3.XY, Angle), Acceleration3.Z);
		QuakeAcceleration(SafeUnit3(Acceleration3), (MaxGroundSpeed * 3.f) / 2.f, 8.f);
		
		//Sprite Animatiom
		PlayIdle();
	}
	
	//////////////////////////////////////////
	// UT
	
	void UTHandleMove()
	{
		if(!Player.OnGround || (Player.OnGround && DashNumber))
		{
			UTAirMove();
			if(pb_ledgegrab) { LedgeGrabInitiator(); }
			if(!Player.OnGround && DashNumber) { DashCooler = 100; }
		}
		else
		{
			MaxGroundSpeed *= GroundSpeedMulti(True);
			UTGroundMove();
			Grappled = False;
			if(pb_dropprevention) { DropPrevention(); }
		}
	}
	
	void UTFriction(Float BrakeFriction)
	{
		if(!Vel.XY.Length()) { return; }
		
		Float RemainingTime = 1.f / TICRATE;
		Float MaxTimeStep = 1.f / 33.f;
		
		while(RemainingTime >= 0.0002f) //value taken from UT4 source code
		{
			Float dt = min(MaxTimeStep, RemainingTime * 0.5f);
			RemainingTime -= dt;
			
			Vel.XY = Vel.XY - BrakeFriction * Vel.XY * dt ;
			
			if(Vel.XY.Length() <= 1.f)
			{
				Vel.XY = (0, 0);
				return;
			}
		}
	}
	
	void UTGroundMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		//Values Reset
		MaxAirSpeed = Vel.XY.Length();
		
		///////////////////////////////////////////
		//Actual Movement
		
		//Dash recovery
		if(DashCooler >= 13)
		{
			UTFriction(3.f * pb_friction); //stronger friction after landing from a dash/walldash
			BlockJump = True;
		}
		else
		{
			//Directional inputs
			Acceleration = RotateVector((cmd.forwardmove, - cmd.sidemove), Angle);
			Acceleration = 200.f * SafeUnit2(Acceleration) * GroundSpeedMulti(False) / pb_friction;
			
			//Friction
			if(Acceleration.Length())
				Vel.XY = Vel.XY - (Vel.XY - Acceleration * Vel.XY.Length()) / TICRATE;
			else
				UTFriction(1.5f * pb_friction); //this feels good
			
			//Acceleration
			Vel.XY += Acceleration / TICRATE;
			
			//Limiter
			Vel.XY = min(Vel.XY.Length(), MaxGroundSpeed) * SafeUnit2(Vel.XY);
		}
		
		//Sprite Animation
		GroundSpriteAnimation();
	}
	
	void UTAirMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		//Directional inputs
		Acceleration = RotateVector((cmd.forwardmove, - cmd.sidemove), Angle);
		Acceleration = 0.62f * SafeUnit2(Acceleration);
		
		//Acceleration
		Vel.XY += Acceleration;
		
		//Limiter
		Vel.XY = min(Vel.XY.Length(), MaxAirSpeed > MaxGroundSpeed ? MaxAirSpeed : MaxGroundSpeed) * SafeUnit2(Vel.XY);
			
		//Sprite Animation
		AirSpriteAnimation();
		
		//Reset speed cap
		if(Vel.XY.Length() <= MaxGroundSpeed) { MaxAirSpeed = Vel.XY.Length(); }
	}
	
	void UTWaterFlyFriction(Float BrakeFriction)
	{
		if(Vel.Length() < 1.f) { return; }
		
		Float RemainingTime = 1.f / TICRATE;
		Float MaxTimeStep = 1.f / 33.f;
		
		while(RemainingTime >= 0.0002f) //value taken from UT4 source code
		{
			Float dt = min(MaxTimeStep, RemainingTime * 0.5f);
			RemainingTime -= dt;
			
			Vel = Vel - BrakeFriction * Vel * dt;
			
			if(Vel.Length() <= 1.f)
			{
				Vel = (0, 0, 0);
				return;
			}
		}
	}
	
	void UTWaterMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		//Value Resets
		MaxAirSpeed = Vel.XY.Length();
		DashCooler = 0;
		
		///////////////////////////////////////////
		//Actual Movement
		
		//Directional inputs
		Acceleration3 = (cmd.forwardmove, - cmd.sidemove, 0);
		//XY
		Acceleration3.XY = 10.f * SafeUnit2(Acceleration3.XY) * GroundSpeedMulti(False);
		//Z
		if(cmd.buttons & BT_JUMP || cmd.buttons & BT_CROUCH)
		{
			Acceleration3.Z = (cmd.buttons & BT_JUMP ? 1 : -1) * 10.f * ActualSpeed;
		}
		else
		{
			Acceleration3.Z = Acceleration3.X * sin(-Pitch);
			Acceleration3.X *= cos(Pitch);
		}
		
		//Friction
		if(WaterLevel == 2) { WaterVelZLimiter(); }
		if(Acceleration3.Length())
			Vel = Vel - (Vel - (RotateVector(Acceleration3.XY, Angle), Acceleration3.Z) * Vel.Length()) / TICRATE;
		else
			UTWaterFlyFriction(2.f);
			
		//Acceleration
		Vel += (RotateVector(Acceleration3.XY, Angle), Acceleration3.Z) / TICRATE;
		
		//Limiter
		Vel = min(Vel.Length(), MaxGroundSpeed / 2.f) * SafeUnit3(Vel);
		
		//Sprite Animation
		GroundSpriteAnimation();
	}
	
	void UTFlyMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		//Value Resets
		MaxAirSpeed = Vel.XY.Length();
		DashCooler = 0;
		
		///////////////////////////////////////////
		//Actual Movement
		
		//Directional inputs
		Acceleration3 = (cmd.forwardmove, - cmd.sidemove, 0);
		//XY
		Acceleration3.XY = 20.f * SafeUnit2(Acceleration3.XY) * GroundSpeedMulti(False);
		//Z
		if(cmd.buttons & BT_JUMP || cmd.buttons & BT_CROUCH)
		{
			Acceleration3.Z = (cmd.buttons & BT_JUMP ? 1 : -1) * 20.f * ActualSpeed;
		}
		else
		{
			Acceleration3.Z = Acceleration3.X * sin(-Pitch);
			Acceleration3.X *= cos(Pitch);
		}
		
		//Friction
		if(Acceleration3.Length())
			Vel = Vel - (Vel - (RotateVector(Acceleration3.XY, Angle), Acceleration3.Z) * Vel.Length()) / TICRATE;
		else
			UTWaterFlyFriction(2.f);
			
		//Acceleration
		Vel += (RotateVector(Acceleration3.XY, Angle), Acceleration3.Z) / TICRATE;
		
		//Limiter
		Vel = min(Vel.Length(), (MaxGroundSpeed * 3.f) / 2.f) * SafeUnit3(Vel);
		
		// Sprite Animatiom
		PlayIdle();
	}
	
	//////////////////////////////////////////
	// Crouching							//
	//////////////////////////////////////////
	
	//////////////////////////////////////////
	// Regular crouching
	
	Override void CheckCrouch(bool totallyfrozen)
	{
		let player = self.player;
		UserCmd cmd = player.cmd;

		if(cmd.buttons & BT_JUMP)
		{
			cmd.buttons &= ~BT_CROUCH;
		}
		
		if(player.health > 0)
		{
			if(!totallyfrozen)
			{
				int crouchdir = player.crouching; // player.crouching from ZMovement 3.2.1
				
				if(bNOGRAVITY || WaterLevel >= 2) //forcefully uncrouch when flying/swimming
					crouchdir = 1; 
				else if(crouchdir == 0) // These will fix crouch toggling. From ZMovement 3.2.1
					crouchdir = (cmd.buttons & BT_CROUCH) ? -1 : 1;
				else if(cmd.buttons & BT_CROUCH) // From ZMovement 3.2.1
					player.crouching = 0;
				
				if(crouchdir == 1 && player.crouchfactor < 1 && pos.Z + height < ceilingz)
					CrouchMove(1);
				else if(crouchdir == -1 && player.crouchfactor > 0.5)
					CrouchMove(-1);
			}
		}
		else
		{
			player.Uncrouch();
		}

		player.crouchoffset = -(ViewHeight) * (1 - player.crouchfactor);
	}
	
	Override void CrouchMove(int direction)
	{
		let player = self.player;
		
		double defaultheight = FullHeight;
		double savedheight = Height;
		double crouchspeed = (CanCSlide && !pb_cslidetype ? - 1.5 : direction) * CROUCHSPEED;
		double oldheight = player.viewheight;

		player.crouchdir = direction;
		player.crouchfactor += crouchspeed;

		// check whether the move is ok
		Height  = defaultheight * player.crouchfactor;
		if(!TryMove(Pos.XY, false, NULL))
		{
			Height = savedheight;
			if(direction > 0)
			{
				// doesn't fit
				player.crouchfactor -= crouchspeed;
				return;
			}
		}
		Height = savedheight;

		player.crouchfactor = clamp(player.crouchfactor, 0.5, 1.);
		player.viewheight = ViewHeight * player.crouchfactor;
		player.crouchviewdelta = player.viewheight - ViewHeight;

		// Check for eyes going above/below fake floor due to crouching motion.
		CheckFakeFloorTriggers(pos.Z + oldheight, true);
	}
	
	//////////////////////////////////////////
	// Crouch Sliding
	
	void CSlideInitiator()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		
		//Check if player is above a damaging floor. We don't cheese map design here!
		
		if(WaterLevel >= 2 || bNOGRAVITY) // in the water or flying forbid attempting to start a slide
		{
			CSlideStartTime = 1;
			QSlideDuration = 0;
			A_StopSound(CHAN_BODY);
			return;
		}
		else if(Player.CrouchFactor == 1 && CSlideStartTime) // reallow attempting to slide after player stands back up
		{
			CSlideStartTime = 0;
			return;
		}
		else if(!Player.OnGround && pb_cslidetype)
		{
			QSlideDuration = abs(Vel.Z) * pb_qslideduration;
		}
		
		if(Player.OnGround)
		{
			if(Player.CrouchFactor != 1 && !CSlideStartTime && CheckInventory("Kicking",1))
			{
				sector sss=floorsector;
				if(A_CheckFloor("null") && sss.damagetype == "Slime" && !pb_hazardmovement) {
					return;
				}
				if(cmd.forwardmove || cmd.sidemove)
				{
					//Not enough space for a slide
					FLineTraceData DirTrace;
					Double SlideAngle = Angle - VectorAngle(cmd.forwardmove, cmd.sidemove);
					LineTrace(SlideAngle, Radius * 2, 0, TRF_SOLIDACTORS|TRF_BLOCKSELF, Height * 0.5, data: DirTrace);
					if(DirTrace.Distance < Radius * 2) { return; }
					
					if(!pb_cslidetype)
					{
						CanCSlide = True;
						A_PlaySound("SlideKick/Start",CHAN_BODY);
						A_GiveInventory("CanSlideKick");
						MaximumSlideSpeed = min(pb_cslidestrength * MaxGroundSpeed, pb_maxhopspeed);
						Vel.XY = MaximumSlideSpeed * AngleToVector(SlideAngle);
					}
					else if(QSlideDuration)
					{
						CanCSlide = True;
						MaximumSlideSpeed = Vel.Length();
					}
				}
				
				CSlideStartTime = Level.MapTime;
			}
			else if(!CanCSlide)
			{
				QSlideDuration = 0;
			}
		}
	}
	
	void CSlideMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = player.cmd;
		
		//Value reset
		MaxAirSpeed = MaxGroundSpeed;
		
		///////////////////////////////////////////
		//Actual Movement
		
		//Directional inputs
		Acceleration = RotateVector((cmd.forwardmove, - cmd.sidemove), Angle);
		Acceleration = 2.f * SafeUnit2(Acceleration);
		
		//Friction (if in the air or slide time has run out)
		if(Level.MapTime > CSlideStartTime + pb_cslideduration)
		{
			Int FrictionDiv = abs(GetZAt(0,0) - Pos.Z) > 16 ? 500 : 100;
			MaximumSlideSpeed *= 1 - Vel.XY.Length() / FrictionDiv;
		}
			
		//Acceleration
		Vel.XY += Acceleration;
		
		//Limiter
		Vel.XY = MaximumSlideSpeed * SafeUnit2(Vel.XY);
		
		//Sprite animation
		PlayIdle();
		
		///////////////////////////////////////////
		//Fun is over
		if(WaterLevel >= 2 || bNOGRAVITY || MaximumSlideSpeed <= MaxGroundSpeed)
		{
			CSlideStartTime = 1;
			CanCSlide = False;
			A_PlaySound("SlideKick/Stop",CHAN_BODY);
			A_TakeInventory("CanSlideKick");
			return;
		}
		
		//Check imminent collision, only needed if previous check did not pass (save calculations)
		FLineTraceData DirTraceGeometry;
		LineTrace(VectorAngle(Vel.X, Vel.Y), 100, 0, TRF_SOLIDACTORS|TRF_BLOCKSELF, Height, data: DirTraceGeometry);
		
		FLineTraceData DirTraceActor;
		LineTrace(VectorAngle(Vel.X, Vel.Y), 100, 0, TRF_SOLIDACTORS|TRF_BLOCKSELF, 0.f, data: DirTraceActor);
		
		//Only stop if the first hit anything or second hit an actor
		if(DirTraceGeometry.Distance < 100.f || (DirTraceActor.Distance < 100.f && DirTraceActor.HitType == TRACE_HitActor))
		{
			CSlideStartTime = 1;
			CanCSlide = False;
			A_PlaySound("SlideKick/Stop", CHAN_BODY);
			A_TakeInventory("CanSlideKick");
		}
	}
	
	void QSlideMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		A_PlaySound("WallSlide", CHAN_BODY, 0.5, True);
		
		///////////////////////////////////////////
		//Actual Movement
		
		//Directional inputs
		Acceleration = (cmd.forwardmove, - cmd.sidemove);
		
		//Friction
		QuakeFriction(MaxGroundSpeed, 6.f);
		
		//Acceleration
		Vector2 PreAccelVel = Vel.XY;
		QuakeAcceleration((RotateVector(SafeUnit2(Acceleration), Angle), 0), max(MaximumSlideSpeed, MaxGroundSpeed), pb_qslideaccel);
		
		//Decrease slide duration depending on how tight turns are
		QSlideDuration--;
		Float SlideRemoveTime = SafeUnit2(PreAccelVel) dot SafeUnit2(Vel.XY);
		SlideRemoveTime = (SlideRemoveTime - 0.99) * 100;
		QSlideDuration -= 1 - SlideRemoveTime;
		
		//Sprite animation
		PlayIdle();
		
		///////////////////////////////////////////
		//Fun is over
		if(QSlideDuration <= 0 || abs(RealFloorZ - Pos.Z) > 16 || !Acceleration.Length() || Player.CrouchFactor == 1)
		{
			CSlideStartTime = QSlideDuration = CanCSlide = 0;
			A_StopSound(CHAN_BODY);
		}
	}
	
	//////////////////////////////////////
	// Dashing							//
	//////////////////////////////////////
	
	void DoubleTapCheck()
	{
		Let Player = Self.Player;
		UserCmd cmd = player.cmd;
		
		Int	MaxTapTime = CVar.GetCVar("zm_maxtaptime", Player).GetInt();
		Int TapValue = (cmd.buttons & BT_FORWARD) + (cmd.buttons & BT_BACK) + (cmd.buttons & BT_MOVERIGHT) + (cmd.buttons & BT_MOVELEFT);
		Int	SecondTapValue;
		
		if(TapValue & ~OldTapValue)
		{
			if(!FirstTapValue)
			{
				FirstTapTime = Level.MapTime;
				FirstTapValue = TapValue;
			}
			else
			{
				if(TapValue != FirstTapValue)
				{
					FirstTapTime = FirstTapValue = 0;
				}
				else
				{
					SecondTapValue = TapValue;
				}
			}
		}
		
		if((FirstTapValue && SecondTapValue) || Level.Maptime > FirstTapTime + MaxTapTime)
		{
			if(SecondTapValue && Level.MapTime <= FirstTapTime + MaxTapTime) { DashInitiator(); }
			FirstTapValue = FirstTapTime = 0;
		}
		
		OldTapValue = TapValue;
	}
	
	void DashInitiator()
	{
		Let Player = Self.Player;
		UserCmd cmd = player.cmd;
		
		if(WaterLevel >= 2 || bNOGRAVITY || Player.CrouchFactor != 1 || LedgeGrabbed || CeilingZ - RealFloorZ <= Height || (pb_movetype == 3 && TrickFailed))
		{
			CheckForWJump = 0;
			Return;
		}
			
		///////////////////////////////////////////////////////
		
		//Ground Dash
		if(pb_dash && Player.OnGround && !((cmd.buttons & BT_JUMP) & !BlockJump) && !DashCooler && (cmd.sidemove || cmd.forwardmove) && !CheckForWJump && !BlockJump)
		{
			if(FloorAngle < 45) { 
				Dash();
			}
			return;
		}
		
		//Wall Jump
		if(!Player.OnGround && pb_wjump)
		{
			if(!CheckForWJump)
			{
				CheckForWJump = 6;
				if(!WJumpSpeed) { WJumpSpeed = Vel.XY.Length(); } //this little trick helps make it feel much better
			}
			else
				CheckForWJump--;
			
			if(cmd.sidemove || cmd.forwardmove)
			{
				//Wall proximity check
				FLineTraceData WallCheck;
				Vector2 WallDir;
				Double WallDistance;
				
				Int w;
				for(w = 0; w < 8; w++)
				{
					LineTrace(w * 45, Radius + 17, 0, 0, data: WallCheck);
						
					if((!WallDistance || WallCheck.Distance <= WallDistance) && WallCheck.HitType == TRACE_HitWall) //Check for the minimum distance
					{
						if(WallCheck.Distance <= Radius + 16)
						{
							WallDistance = WallCheck.Distance;
							WallDir = WallCheck.HitDir.XY;
						}
					}
				}
				
				//No obstacles near player check
				FLineTraceData DirTrace;
				LineTrace(Angle - VectorAngle(cmd.forwardmove, cmd.sidemove), Radius + 33, 0, TRF_SOLIDACTORS|TRF_BLOCKSELF, data: DirTrace);	
				if(DirTrace.Distance >= Radius + 32 && WallDistance)
				{
					//Moving away from the wall
					Float DirDelta = AbsAngle(VectorAngle(DirTrace.HitDir.X, DirTrace.HitDir.Y), VectorAngle(WallDir.X, WallDir.Y));
					if(DirDelta >= 95)
					{
						CheckForWJump = 0;
						WallJump();
						return;
					}	
				}
				else
				{
					CheckForWJump = 0;
				}
			}
		}
		else
		{
			CheckForWJump = 0;
		}
		
		//Air Dash
		if(pb_airdash && !Player.OnGround && (cmd.sidemove || cmd.forwardmove) && !ADashTargetSpeed && !DashCooler && !ADashCooler)
		{
			//No obstacles near player check
			FLineTraceData DirTrace;
			LineTrace(Angle - VectorAngle(cmd.forwardmove, cmd.sidemove), Radius + 33, 0, TRF_SOLIDACTORS|TRF_BLOCKSELF, data: DirTrace);
							
			if(DirTrace.Distance >= Radius + 32)
			{
				AirDash();
				return;	
			}
		}
	}
	
	
	void Dash()
	{
		Let Player = Self.Player;
		UserCmd cmd = player.cmd;
		
		
		//Check if player is above a damaging floor. We don't cheese map design here!
        sector sss=floorsector;
		if(A_CheckFloor("null") && sss.damagetype == "Slime" && !pb_hazardmovement) {
			A_Playsound("Daedabus/impact", CHAN_BODY);
			return;
		}
		
		if(DashNumber > 3) { return; }
		DashNumber++;
		
		Float DashVelZ = pb_jumpheight * pb_dashheight + ElevatorJumpBoost;
		Float JumpFac = GetPowerJump();
		if(JumpFac) { DashVelZ *= JumpFac; }
		Vel.Z = DashVelZ;
		
		if(!(player.cheats & CF_PREDICTING)) { 
			A_PlaySound("JMPBOOT", CHAN_BODY);
			A_Playsound("DBLJUMP", CHAN_AUTO);
			A_GiveInventory("PlayerDashed");
			alphaFade = 0.1;
		}
		
		Vel.XY = pb_dashboost * MaxGroundSpeed * AngleToVector(Angle - VectorAngle(cmd.forwardmove , cmd.sidemove)); //boost proportional to max ground speed
		MaxAirSpeed = min(Vel.XY.Length(), pb_maxhopspeed);
		
		if(pb_movetype == 3) //only needed for PK movement
		{
			SmallerJumpHeight++;
			Acceleration = 30.f * SafeUnit2((cmd.forwardmove, - cmd.sidemove));
		}
	}
	
	void AirDash()
	{
		Let Player = Self.Player;
		UserCmd cmd = player.cmd;
		
		ADashCooler = 53;
		DashNumber++;
		
		if(!(player.cheats & CF_PREDICTING)) { A_PlaySound("*jump", CHAN_BODY); }
		
		if(Vel.XY.Length() <= MaxGroundSpeed)
		{
			Vel.XY = (MaxGroundSpeed + pb_adashboost) * AngleToVector(Angle - VectorAngle(cmd.forwardmove , cmd.sidemove)); //this way the air dash always grants a satisfying boost
			ADashTargetSpeed = MaxGroundSpeed + (pb_movetype == 2 && pb_movetype == 3 && pb_movetype == 4 ? (Vel.XY.Length() - MaxGroundSpeed) / 4 : 0);
			ADashFrictionDelay = 8;
		}
		else
		{
			Float PreAirDashSpeed = Vel.XY.Length();
			Vel.XY += pb_adashboost * AngleToVector(Angle - VectorAngle(cmd.forwardmove , cmd.sidemove));
			
			ADashTargetSpeed = min(PreAirDashSpeed + (pb_movetype == 2 && pb_movetype == 3 && pb_movetype == 4 ? (Vel.XY.Length() - PreAirDashSpeed) / 4 : 0), pb_maxhopspeed);
			
			//if going above the speed limit your speed will start decaying immediately
			Float Velocity = Vel.XY.Length();
			if(Velocity > PreAirDashSpeed && Velocity <= pb_maxhopspeed) { ADashFrictionDelay = 8; }
		}
			
		MaxAirSpeed = Vel.XY.Length();
		
		if(pb_movetype == 3) //only needed for PK movement
		{
			Acceleration = 30.f * SafeUnit2((cmd.forwardmove, - cmd.sidemove));
			ActualMaxAirSpeed = MaxAirSpeed;
		}
	}
	
	void AirDashFriction()
	{
		if(!ADashFrictionDelay)
		{
			if(Vel.XY.Length() > ADashTargetSpeed)
			{
				Vel.XY *= 1 - Vel.Length() / (1000 * pb_adashfriction); //just like in real life air friction is proportional to the speed
				MaxAirSpeed = Vel.XY.Length();
			}
			else
			{
				MaxAirSpeed = ADashTargetSpeed;
				ADashTargetSpeed = 0;
			}
		}
		else
		{
			ADashFrictionDelay--;
		}
	}
	
	void WallJump()
	{
		Let Player = Self.Player;
		UserCmd cmd = player.cmd;
		
		//Stop any eventual WallSlideMove
		StopWSlide();
		
		DashNumber++;
		if(DashNumber <= 3)
		{
			Float DashVelZ = pb_jumpheight * pb_dashheight;
			Float JumpFac = GetPowerJump();
			if(JumpFac) { DashVelZ *= JumpFac; }
			Vel.Z = DashVelZ;
		}
		
		if(zm_wjdoublejumprenew) { CanDoubleJump = True; }
		
		if(!(player.cheats & CF_PREDICTING)) { A_PlaySound("*jump", CHAN_BODY); }
		
		Float EstimatedWJumpSpeed1 = pb_wjumpboost * MaxGroundSpeed;
		Float EstimatedWJumpSpeed2 = pb_multipledashes + max(WJumpSpeed, Vel.XY.Length()); //WJumpSpeed can be stored a few tics before wall inpact which slows down player, allowing for more satisfying WJumps
		WJumpSpeed = max(EstimatedWJumpSpeed1, EstimatedWJumpSpeed2);
		
		Vel.XY = min(WJumpSpeed, pb_maxhopspeed) * AngleToVector(Angle - VectorAngle(cmd.forwardmove , cmd.sidemove));
		MaxAirSpeed = min(Vel.XY.Length(), pb_maxhopspeed);
		
		if(pb_movetype == 3) //only needed for PK movement
		{
			SmallerJumpHeight++;
			ActualMaxAirSpeed = MaxAirSpeed;
			Acceleration = 30.f * SafeUnit2((cmd.forwardmove, - cmd.sidemove));
		}
	}
	
	//////////////////////////////////////
	// Wall Slide				 		//
	//////////////////////////////////////
	
	void WallSlideInitiator()
	{
		Let Player = Self.Player;
		UserCmd cmd = player.cmd;
		
		if(Player.OnGround || WaterLevel >= 2 || bNOGRAVITY || LedgeGrabbed)
		{
			CheckForWSlide = 0;
			return;
		}
		else if(!CheckForWSlide)
		{
			CheckForWSlide = 24;
		}
		
		CheckForWSlide--;
		
		FLineTraceData DirTrace;
		Int SlideAngleDelta;
		
		if(!WSlideVelocity.Length())
		{
			LineTrace(VectorAngle(Vel.X, Vel.Y), 100, 0, 0, data: DirTrace);
			if(DirTrace.Distance < 100 && DirTrace.HitType == TRACE_HitWall) { WSlideVelocity = Vel.XY; }
		}
		else
		{
			SlideAngleDelta = AbsAngle(VectorAngle(WSlideVelocity.X, WSlideVelocity.Y), VectorAngle(Vel.X, Vel.Y));
		}
		
		if(SlideAngleDelta && SlideAngleDelta <= 45)
		{
			WSlideVelocity =  WSlideVelocity.Length() * SafeUnit2(Vel.XY);
			Vel.XY = WSlideVelocity;
			CanWSlide = True;
			CheckForWSlide = 0;
			return;
		}
	}
	
	void WallSlideMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = player.cmd;
		
		//////////////////////////////////////////////////////
		//Dumb ways to fail...so many don't waste your time
		
		//Common reasons of failure
		if(!WaterLevel >= 2 || bNOGRAVITY || Player.OnGround || (!cmd.forwardmove && !cmd.sidemove))
		{
			StopWSlide();
			return;
		}
		
		//WallCheck
		Float WallDistance;
		FLineTraceData SlideWallCheck;
		Int i;
		for(i = 0; i < 8; i++)
		{
			LineTrace(i * 45, (Radius * 3) / 2, 0, 0, data: SlideWallCheck);
			if(!WallDistance || SlideWallCheck.Distance <= WallDistance) { WallDistance = SlideWallCheck.Distance; }
		}
		if(WallDistance >= (Radius * 3) / 2)
		{
			StopWSlide();
			return;
		}
		
		//Moving away from wall
		Float WishDirection = Angle - VectorAngle(cmd.forwardmove, cmd.sidemove);
		Float VelAngle = VectorAngle(Vel.X, Vel.Y);
		Float DirAngle = AbsAngle(WishDirection, VelAngle);
		if(DirAngle >= 30)
		{
			StopWSlide();
			return;
		}
		
		//Wall changed angle, adjust slide velocity
		Int SlideAngleDelta = AbsAngle(VectorAngle(WSlideVelocity.X, WSlideVelocity.Y), VelAngle);
		if(SlideAngleDelta && SlideAngleDelta <= 30)
		{
			WSlideVelocity = WSlideVelocity.Length() * SafeUnit2(Vel.XY);
			Vel.XY = WSlideVelocity; //needed to not make velocity check fail
		}
		else if(SlideAngleDelta > 30)
		{
			StopWSlide();
			return;
		}
		
		//Too slow
		if(Vel.XY.Length() < MaxGroundSpeed)
		{
			StopWSlide();
			return;
		}
		
		//////////////////////////////////////////////////////
		
		Vel.XY = WSlideVelocity;
		Vel.Z *= pb_wslidevelz;
		A_PlaySound("WallSlide", CHAN_BODY, 0.3, True);
		
		//Sprite animation
		PlayIdle();
	}
	
	void StopWSlide()
	{
		CanWSlide = False;
		WSlideVelocity = (0, 0);
		A_StopSound(CHAN_BODY);
	}
	
	//////////////////////////////////////
	// Ledge Grab						//
	//////////////////////////////////////
	
	void LedgeGrabInitiator()
	{
		let player = self.player;
		
		FLineTraceData LedgeTrace;
		Float TraceDistanceW = sqrt(2) * Radius + 1; //account for the fact that Doom's hitboxes are square
		Float TraceDistanceL;
		Sector LedgeSector;

		int l;
		for(l = 0; l < 3; l++)
		{
			if(!TraceDistanceL) //Scan environment from chest height up to above head
			{
				LineTrace(Angle, TraceDistanceW, 0, TRF_BLOCKSELF|TRF_THRUACTORS, Height * (0.6f + 0.3f * l), data: LedgeTrace);
				//Hit Geometry
				if(LedgeTrace.Distance < TraceDistanceW && LedgeTrace.HitType == TRACE_HitWall) { TraceDistanceL = LedgeTrace.Distance + 5; }
			}
			else //Only check for a ledge after geometry was hit, since you need to look for empty space *above* the hit spot
			{
				//Tracer stopped by solid actors and by impassable midtextures
				LineTrace(Angle, TraceDistanceL + 1, 0, TRF_SOLIDACTORS|TRF_BLOCKSELF, Height * (0.6f + 0.3f * l), data: LedgeTrace);
				
				if(LedgeTrace.Distance > TraceDistanceL)
				{
					LedgeSector = LedgeTrace.HitSector;
					break; //no need to keep looking if we already have a result
				}
			}
			
			//No ledge, stop. I have very rarely encountered an issue where GZDoom would get stuck without reporting erros. Endless loops are the first
			//lines of code to be considered culprit of such problem, for safety I added l >= 3 to the return to make sure if something goes very wrong 
			//the engine does not freeze
			if((l == 2 && !LedgeSector) || l >= 3) { return; }
		}
		
		//If player is in slime, they cannot cheese their way out of it and break maps
		sector sss=floorsector;
		if(A_CheckFloor("null") && sss.damagetype == "Slime" && !pb_hazardmovement) {
			return;
		}
		
		//Check if there is enough space in the current sector for player to raise (+5 for safety)
		Vector3 Hit = LedgeTrace.HitLocation;
		Int MinimumHeight = Height + 5;
		LedgeHeight = LedgeSector.NextLowestFloorAt(Hit.X + cos(Angle), Hit.Y + sin(Angle), Hit.Z, FFCF_3DRESTRICT, 0);
		if(CeilingZ - LedgeHeight < MinimumHeight) { return; }
		
		//Check there is no actor above player
		FLineTraceData ActorCheck;
		Int HeightCheck = (LedgeHeight + MinimumHeight) - (Pos.Z + Height);
		LineTrace(Angle, HeightCheck, -90, TRF_SOLIDACTORS, Height, data: ActorCheck);
		if(ActorCheck.Distance < HeightCheck) { return; }
		
		//Check if landing sector is high enough to host player
		Int LedgeCeiling = LedgeSector.NextHighestCeilingAt(Hit.X + cos(Angle), Hit.Y + sin(Angle), Hit.Z, FFCF_3DRESTRICT, 0);
		if(LedgeCeiling - LedgeHeight < MinimumHeight) { return; }
		
		//Find if there is enough space to fit player on the sides using the power of math
		Float RequiredTracerDistance = sqrt(Radius * Radius + LedgeTrace.Distance * LedgeTrace.Distance);
		Float TracerAngle = asin(Radius / RequiredTracerDistance);
		FLineTraceData SideTracer;
		
		int s;
		for(s = -1; s < 2; s++)
		{
			if(s)
			{
				LineTrace(Angle + TracerAngle * s, RequiredTracerDistance, 0, TRF_SOLIDACTORS|TRF_BLOCKSELF, Hit.Z - Pos.Z, data: SideTracer);
				if(SideTracer.Distance < RequiredTracerDistance || s >= 2) { return; } //s >= 2 just in case
			}
		}
			
		//Switch to a weapon that forbids firing during the ledge grab
		//ReselectWeapon = Player.ReadyWeapon;
		GiveInventory("Grabbing_A_Ledge", 1);
		//Player.ReadyWeapon = Null;
		//Let AssignWeapon = LedgeGrabWeapon(FindInventory("LedgeGrabWeapon"));
		//Player.PendingWeapon = AssignWeapon;
		
		//Reset dash stuff just in case
		MaxAirSpeed = ADashTargetSpeed;
		DashCooler = ADashCooler = ADashTargetSpeed = WJumpSpeed = DashNumber = 0;
		
		//Allow ledge grab
		A_StopSound(CHAN_WEAPON); 	//stop looping weapon sounds
		StopHook();					//stop hook, not needed but just in case
		LedgeAngle = Angle;
		A_SetPitch(sin(Angle));
		A_PlaySound("ledgeclimb", CHAN_BODY);
		LedgeGrabbed = True;
	}
	
	void LedgeGrab()
	{
		let player = self.player;
		
		if(Pos.Z >= LedgeHeight || !Vel.Length())
		{
			//Reassign weapon
		//	Player.PendingWeapon = ReselectWeapon;
			TakeInventory("Grabbing_A_Ledge", 1);
			//End Ledge Grab
			Vel = Vel.Length() ? (5.f * AngleToVector(LedgeAngle), -3) : (0, 0, 0); //push player forward and downward
			A_PlaySound("*land", CHAN_BODY);
			LedgeGrabbed = LedgeTime = 0;
		}
		else
		{
			Vel = Vel.Length() ? (0, 0, 8) : (0, 0, 0);
		}
		
		//Fail safe to unlock player movement if something goes wrong
		LedgeTime++;
		if(LedgeTime >= 35)
		{
			//Player.PendingWeapon = ReselectWeapon;
			TakeInventory("Grabbing_A_Ledge", 1);
			LedgeGrabbed = LedgeTime = 0;
		}
		
		//Sprite animation
		PlayIdle();
	}
	
	//////////////////////////////////////
	// Grappling Hook 					//
	//////////////////////////////////////
	
	// A very cool concept, but breaks gameplay and allows players to cheese things
	void FireHook()
	{
		A_Print("Grappling Hook has been disabled");
		return;
	
		Let Player = self.player;
		//Heavy metal music stops
		if(WaterLevel >= 2 || bNOGRAVITY) { return; }
		//Third click, detach hook
		if(PendulumLength || (GrappleVel.Length() && pb_hook == 1))
		{
			StopHook();
			return;
		}
		//Second click, activate pendulum physics
		if(GrappleVel.Length() && pb_hook == 2)
		{
			Float RopePitch = atan2(Rope.XY.Length(), Rope.Z);
			//Trust me, it's better if you do not see what happens otherwise
			if(RopePitch >= 90.f)
			{
				StopHook();
				return;
			}
			//Initiate pendulum
			PendulumLength = Rope.Length();
			RopePitch *= (Vel.Z < 0 ? -1 : 1);
			Float SwingPitch = RopePitch + 90;
			Float SwingAngle = VectorAngle(Vel.X, Vel.Y);
			Vel = GrappleVel.Length() * (sin(SwingPitch) * cos(SwingAngle), sin(SwingPitch) * sin(SwingAngle), cos(SwingPitch));
			GrappleVel = Vel;
			return;
		}
		//First click, fire hook
		if(HookFired || Grappled) { return; }
		A_PlaySound("HookLaunch", 7, 0.8);
		HookFired = SpawnPlayerMissile("Hook", Angle, 0, 0, - Height / 14.f); //SpawnPlayerMissile fires a projectile at 8/14 of Player Height, I need it to be fired at half
	}
	
	bool HookLOS()
	{
		Float LOSPitch = atan2(Rope.XY.Length(), Rope.Z) - 90;
		Float LOSAngle = VectorAngle(Rope.X, Rope.Y);
		FLineTraceData LOSCheck;
		LineTrace(LOSAngle, Rope.Length(), LOSPitch, TRF_SOLIDACTORS|TRF_BLOCKSELF, Height / 2.f, data: LOSCheck);
		
		if(GrappledMonster != Null && LOSCheck.HitActor == GrappledMonster) { return true; }
		
		return LOSCheck.Distance == Rope.Length();
	}
	
	void GrapplingMove()
	{
		Let Player = self.player;
		
		if(!Player.OnGround) { Grappled = True; }
		
		//Fun is over kids, go home
		if((Player.OnGround && Grappled) || WaterLevel >= 2 || bNOGRAVITY || Rope.Length() <= 4.f * Radius || float(Vel.Length() - GrappleVel.Length()) < 0.f || !HookLOS() || !Vel.Length())
		{
			StopHook();
			return;
		}
		
		//All good
		if(PendulumLength)
		{
			//Reached the peak
			Float RopePitch = atan2(Rope.XY.Length(), Rope.Z);
			if(RopePitch >= 90)
			{
				StopHook();
				return;
			}
			
			Vector3 SwingVel;
			if(Vel.Z < 0)
			{
				SwingVel = (GrappleVel.X, GrappleVel.Y, GrappleVel.Z - pb_setgravity);
			}
			else
			{
				SwingVel = (GrappleVel.X, GrappleVel.Y, GrappleVel.Z - pb_setgravity / 2.f);
				RopePitch *= -1;
			}
			Float SwingPitch = RopePitch + 90;
			Float SwingAngle = VectorAngle(Vel.X, Vel.Y);
			Vel = SwingVel.Length() * (sin(SwingPitch) * cos(SwingAngle), sin(SwingPitch) * sin(SwingAngle), cos(SwingPitch));
			
			//Rope tension
			Float Tension = Rope.Length() - PendulumLength;
			if(Tension) { Vel += Tension * SafeUnit3(Rope); }
			
			//Limiter
			MaxAirSpeed = min(Vel.XY.Length(), pb_maxhopspeed);
			Vel.XY = MaxAirSpeed * SafeUnit2(Vel.XY);
			
			GrappleVel = Vel;
		}
		else
		{
			GrappleVel = SafeUnit3(Rope) * GrappleVel.Length();
			Vel = GrappleVel;
		}
		
		//Sprite animation
		PlayIdle();
	}
	
	void StopHook()
	{
		Rope = GrappleVel = (0, 0, 0);
		PendulumLength = 0;
		GrappledMonster = Null;
	}
	
	//////////////////////////////////////
	// Bobbing							//
	//////////////////////////////////////
	
	void BobWeaponAuxiliary()
	{	
		///////////////////////////
		//Bobbing Speed
		if(MoveRangeMulti) { BobTime += Vel.XY.Length() / pb_maxgroundspeed; }
		
		///////////////////////////
		//Bobbing Range
		Double MaxBobCandidate = pb_maxgroundspeed * ZMoveFactor;
		
		if(MaxBobCandidate == MaxBob || !MaxBob)
		{
			MaxBob = MaxBobCandidate;
		}
		else
		{
			if(MaxBobCandidate > MaxBob)
			{
				MaxBob += 0.5f;
				MaxBob = min(MaxBob, MaxBobCandidate);
			}
			else
			{
				MaxBob -= 0.5f;
				MaxBob = max(MaxBob, MaxBobCandidate);
			}
		}
	}
	
	Override Vector2 BobWeapon(double ticfrac)
	{
		let player = self.player;
		UserCmd cmd = player.cmd;
		
		Vector2 p1, p2, r;
		Vector2 result;
		
		if(!player) return (0, 0);
		let weapon = player.ReadyWeapon;

		if(weapon == null || weapon.bDontBob || !(player.WeaponState & WF_WEAPONBOBBING))
		{
			MoveRangeMulti = StillRangeMulti = XBob = XBobOffset = YBob = 0;
			return (0, 0);
		}
		
		Int BobStyle = weapon.BobStyle;
		Double BobSpeed = weapon.BobSpeed * 128;
		Double RangeX = weapon.BobRangeX;
		Double RangeY = weapon.BobRangeY;

		for(int i = 0; i < 2; i++)
		{
			if(WaterLevel >= 2 || bNOGRAVITY) //water, flying
			{
				XBob *= abs(XBob) > 0.1 ? 0.988 : 0;
				YBob *= abs(YBob) > 0.1 ? 0.988 : 0;
			}
			else if(ZMJumpTics || abs(RealFloorZ - Pos.Z) > 16 || CanCSlide || CanWSlide) //mid air or csliding or wallsliding
			{
				if(CanWSlide || CanCSlide || GrappleVel.Length()) //don't you move boi
				{
					XBob *= abs(XBob) > 0.1 ? 0.988 : 0;
					YBob *= abs(YBob) > 0.1 ? 0.988 : 0;
				}
				else //vertical offset
				{
					Int OffsetSpeed = CVar.GetCVar("zm_offsetspeed", Player).GetInt();
					Int	OffsetRange = CVar.GetCVar("zm_offsetmaxrange", Player).GetInt();
					
					if(Xbob) { XBob *= abs(XBob) > 0.1 ? 0.988 : 0; }
					
					if(!CVar.GetCVar("zm_offsetdirection", Player).GetBool())
					{
						if(Vel.Z >= 0)
							YBob += Vel.Z / OffsetSpeed * (1. - abs(YBob) / OffsetRange);
						else
							YBob += 2. * Vel.Z / OffsetSpeed * max(abs(YBob) / OffsetRange, 1);
					}
					else
					{
						if(Vel.Z >= 0)
							YBob -= 2. * Vel.Z / OffsetSpeed * max(abs(YBob) / OffsetRange, 1);
						else
							YBob -= Vel.Z / OffsetSpeed * (1. - abs(YBob) / OffsetRange);
					}
					
					YBob = clamp(YBob, 0, OffsetRange);
				}
				
				HoppingBob = True;
				MoveRangeMulti = StillRangeMulti = BobTime = 0;
			}
			else //ground movement
			{
				if(HoppingBob)
				{
					XBob *= abs(XBob) > 0.1f ? 0.988 : 0;
					YBob *= abs(YBob) > 0.1f ? 0.988 : 0;
					if(!XBob && !YBob) { HoppingBob = False; }
				}
				else
				{
					//Float SpeedToFullBob = CVar.GetCVar("zm_fullbobspeed", Player).GetInt();
					Float SpeedToFullBob = max(1, CVar.GetCVar("zm_fullbobspeed", Player).GetInt());
					
					if((cmd.forwardmove || cmd.sidemove) && Vel.XY.Length() > 1.f)
					{	
						BobRangeMulti = min(Vel.XY.Length(), pb_maxgroundspeed) / pb_maxgroundspeed;
						MoveRangeMulti = min(MoveRangeMulti + BobRangeMulti / SpeedToFullBob, MaxBob);
						StillRangeMulti = 0;
					}
					else
					{
						if(MoveRangeMulti)
						{
							MoveRangeMulti = max(MoveRangeMulti - max(BobRangeMulti / SpeedToFullBob, 0.1f), 0);
						}
						else
						{
							XBob = BobTime = 0;
							if(CVar.GetCVar("zm_stillbob", Player).GetBool()) //still weapon bobbing
							{
								StillRangeMulti = min(StillRangeMulti + 0.001, 1); //probably nobody would notice the occasional tiny warps BUT I WOULD KNOW
								YBob = StillRangeMulti * sin(Level.Maptime / 120. * 360.) + StillRangeMulti;
							}
							else
							{
								YBob = 0;
							}
						}
					}
						
					if(MoveRangeMulti)
					{
						Double BobAngle = (BobSpeed * player.GetWBobSpeed() * (BobTime - 1 + i)) * (360. / 8192.);
						Double BobXMulti = (MoveRangeMulti * RangeX);
						Double BobYMulti = (MoveRangeMulti * RangeY);
						
						switch(BobStyle)
						{
							case Bob_Normal:
								XBob = BobXMulti * cos(BobAngle);
								YBob = BobYMulti * abs(sin(BobAngle));
								break;
							
							case Bob_Inverse:
								XBob = BobXMulti * cos(BobAngle);
								YBob = BobYMulti * (1. - abs(sin(BobAngle)));
								break;
							
							case Bob_Alpha:
								XBob = BobXMulti * sin(BobAngle);
								YBob = BobYMulti * abs(sin(BobAngle));
								break;
							
							case Bob_InverseAlpha:
								XBob = BobXMulti * sin(BobAngle);
								YBob = BobYMulti * (1. - abs(sin(BobAngle)));
								break;
							
							case Bob_Smooth:
								XBob = BobXMulti * cos(BobAngle);
								YBob = 0.5f * (BobYMulti * (1. - (cos(BobAngle * 2))));
								break;
							
							case Bob_InverseSmooth:
								XBob = BobXMulti * cos(BobAngle);
								YBob = 0.5f * (BobYMulti * (1. + (cos(BobAngle * 2))));
								break;
							
							case Bob_Build:
								XBob = 2.f * BobXMulti * cos(BobAngle);	
								YBob = BobYMulti * (1. - abs(sin(BobAngle)));
								break;
							
							case Bob_Dusk:
								XBob = 0.f;
								YBob = BobYMulti * (cos(BobAngle));
								break;
							
							case Bob_Painkiller:
								XBob = BobXMulti * cos(BobAngle);	
								YBob = - BobYMulti * (1. - abs(sin(BobAngle)));
								break;
							
							case Bob_UT:
								XBob = 1.5 * BobXMulti * cos(BobAngle);	
								YBob = BobYMulti * sin(2.f * BobAngle);
						}
					}
				}
			}
			
			r = (XBob, YBob);
			
			//properly align sprites for the animations that require it
			switch(BobStyle)
			{
				case Bob_Dusk:
					r.Y += pb_maxgroundspeed * RangeY;
					break;
				
				case Bob_Painkiller:
					r.Y += pb_maxgroundspeed * RangeY;
					break;
					
				case Bob_UT:
					r.Y += pb_maxgroundspeed * RangeY;
			}
			
			//////////////////////////////
			//Yaw Weapon Sway
			if(CVar.GetCVar("zm_yawsway", Player).GetBool() && !FindInventory("PlayerWheelOpen"))
			{
				Double SwayRange = CVar.GetCVar("zm_yawswayrange", Player).GetFloat() * 10;
				Double SwayFrictionMulti = CVar.GetCVar("zm_yawswayfriction", Player).GetFloat() / 10;
				
				XBobOffset += (CVar.GetCVar("zm_yawswaydirection", Player).GetBool() ? -1 : 1) * ViewAngleDelta * CVar.GetCVar("zm_yawswayspeed", Player).GetFloat() / 50;
				
				if(abs(XBobOffset) > 0.2)
					XBobOffset -= XBobOffset / ((1.5 - SwayFrictionMulti) * 100);
				else if(!ViewAngleDelta)
					XBobOffset = 0;
				
				r.X += clamp(XBobOffset, -SwayRange, SwayRange);
			}
			else
			{
				XBobOffset = 0;
			}
				
			//////////////////////////////
			
			if(i == 0) p1 = r; else p2 = r;
		}
		return p1 * (1. - ticfrac) + p2 * ticfrac;
	}
	
	// The rest of Project Brutality player class
	Default
	{
		PlayerPawnBase.TankTurretSpriteActor "TankTurretNotReal";
	}
	void SpawnTankSprite()
	{
		if (TankBaseSprite) return;
		TankBaseSprite = TankBaseNotReal(Spawn("TankBaseNotReal",self.pos + self.vel,ALLOW_REPLACE));
		TankTurretSprite = Spawn(TankTurretSpriteActor,self.pos + self.vel,ALLOW_REPLACE);
	}
	void DestroyTankSprites()
	{
		TankBaseSprite.Destroy();
		TankTurretSprite.Destroy();
		TankBaseSprite = NULL;
		TankTurretSprite = NULL;
	}
	void SetTankSpritePosition(int spritestate,double angle = 0)
	{
		if (TankBaseSprite != NULL)
		{
			TankBaseSprite.SetOrigin(self.pos + self.vel,true);
			TankBaseSprite.spritestate = spritestate;
			TankBaseSprite.angle = angle;
		}
	}
	
	void CheckTargetHitRegistration()
	{
		// Check the parent class the monster is derived from
		//let target_ptr = AAPTR_PLAYER_GETTARGET;
		if (GetPointer(AAPTR_PLAYER_GETTARGET) is "PB_Monster"){
			//A_Print("This is a PB Monster!!!"); // Debug code
			A_GiveInventory("HeadshotToken", 1, AAPTR_PLAYER_GETTARGET);
		}
	}
	
	void InitPDAWeaponList()
	{
		if (FindInventory("PB_PDAWeaponContainer")) return;
		A_GiveInventory("PB_PDAWeaponContainer",1);
		PB_PDAWeaponContainer pdaweapContainer = PB_PDAWeaponContainer(FindInventory("PB_PDAWeaponContainer"));
		if (pdaweapContainer) pdaweapContainer.InitializePDATexts();
	}
	
	override void Die(Actor source, Actor inflictor, int dmgflags)
	{
		A_TakeInventory("CameraRunner",1);
		Super.Die(source, inflictor, dmgflags);
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		if (!level.IsJumpingAllowed() || (player && player.mo && player.mo.JumpZ == 0)) A_GiveInventory("DoNotDoubleJump",1);
	}
	override void Tick()
	{
		Super.Tick();
		
		CheckTargetHitRegistration();
		
		//Screen Overlay Handlers
		if (GetCvar("BloodSplash") == 1) {
			if (CheckInventory("RedBloodSplatterz",1)) {
				A_TakeInventory("RedBloodSplatterz", 1);
				A_Giveinventory("BloodOnVisor",1);
				int selector = (random(0,1));
				if (selector == 0){ACS_NamedExecute("RedBloodSplatter580", 0);}
				if (selector == 1){ACS_NamedExecute("RedBloodSplatter580", 1);}
			}
			
			if (CheckInventory("BlueBloodSplatterz",1)) {
				A_TakeInventory("BlueBloodSplatterz", 1);
				A_Giveinventory("BlueBloodOnVisor",1);
				int selector = (random(0,1));
				if (selector == 0){ACS_NamedExecute("BlueBloodSplatter583", 0);}
			}
			if (CheckInventory("GreenBloodSplatterz",1)) {
				A_TakeInventory("GreenBloodSplatterz", 1);
				A_Giveinventory("GreenBloodOnVisor",1);
				int selector = (random(0,1));
				if (selector == 0){ACS_NamedExecute("GreenBloodSplatter582", 0);}
			}
			if (CheckInventory("BloodSplasherz",1)) {
				A_TakeInventory("BloodSplasherz", 1);
				A_Giveinventory("BloodOnVisor",1);
				int selector = (random(0,5));
				if (selector == 0){ACS_Execute(580, 0, 0, 0, 0);}
				if (selector == 1){ACS_Execute(581, 0, 0, 0, 0);}
				if (selector == 2){ACS_Execute(582, 0, 0, 0, 0);}
				if (selector == 3){ACS_Execute(583, 0, 0, 0, 0);}
				if (selector == 4){ACS_Execute(584, 0, 0, 0, 0);}
				if (selector == 5){ACS_Execute(585, 0, 0, 0, 0);}
			}
		}
		if (CheckInventory("WaterSplasherz",1)) {
			A_TakeInventory("WaterSplasherz", 1);
			A_Giveinventory("WaterOnVisor",1);
			int selector = (random(0,4));
			if (selector == 0){ACS_Execute(550, 0, 0, 0, 0);}
			if (selector == 1){ACS_Execute(551, 0, 0, 0, 0);}
			if (selector == 2){ACS_Execute(552, 0, 0, 0, 0);}
			if (selector == 3){ACS_Execute(554, 0, 0, 0, 0);}
			if (selector == 4){ACS_Execute(555, 0, 0, 0, 0);}
		}
		if (CheckInventory("SlimeSplasherz",1)) {
			A_TakeInventory("SlimeSplasherz", 1);
			A_Giveinventory("SlimeOnVisor",1);
			int selector = (random(0,5));
			if (selector == 0){ACS_Execute(540, 0, 0, 0, 0);}
			if (selector == 1){ACS_Execute(541, 0, 0, 0, 0);}
			if (selector == 2){ACS_Execute(542, 0, 0, 0, 0);}
			if (selector == 3){ACS_Execute(543, 0, 0, 0, 0);}
			if (selector == 4){ACS_Execute(544, 0, 0, 0, 0);}
			if (selector == 5){ACS_Execute(545, 0, 0, 0, 0);}
		}
		if (CheckInventory("SludgeSplasherz",1)) {
			A_TakeInventory("SludgeSplasherz", 1);
			A_Giveinventory("SludgeOnVisor",1);
			int selector = (random(0,5));
			if (selector == 0){ACS_Execute(5530, 0, 0, 0, 0);}
			if (selector == 1){ACS_Execute(5531, 0, 0, 0, 0);}
			if (selector == 2){ACS_Execute(5532, 0, 0, 0, 0);}
			if (selector == 3){ACS_Execute(5533, 0, 0, 0, 0);}
			if (selector == 4){ACS_Execute(5534, 0, 0, 0, 0);}
			if (selector == 5){ACS_Execute(5535, 0, 0, 0, 0);}
		}
		
		if (CheckInventory("LavaSplasherz",1)) {
			A_TakeInventory("LavaSplasherz", 1);
			A_Giveinventory("LavaOnVisor",1);
			int selector = (random(0,5));
			if (selector == 0){ACS_NamedExecute("LavaScreenSplash550", 0);}
			if (selector == 1){ACS_NamedExecute("LavaScreenSplash551", 0);}
			if (selector == 2){ACS_NamedExecute("LavaScreenSplash552", 0);}
			if (selector == 3){ACS_NamedExecute("LavaScreenSplash553", 0);}
			if (selector == 4){ACS_NamedExecute("LavaScreenSplash554", 0);}
			if (selector == 5){ACS_NamedExecute("LavaScreenSplash555", 0);}
		}
		
		if (IsTank && !(health <= 0))
		{
			if (TankTurretSprite != NULL)
			{
				//TankTurretSprite.Tics = -1;
				TankTurretSprite.A_Setangle(self.angle,SPF_INTERPOLATE);
				TankTurretSprite.SetOrigin(self.pos + self.vel,true);
				TankTurretSprite.bINVISIBLE = false;
			}
			if (health < 500)
			{
				A_SpawnProjectile ("BigNeoSmoke", 0, 0, random (0, 360), 2, -random (0, 360));
				A_SpawnProjectile ("ExplosionSmoke", 0, 0, random (0, 360), 2, -random (0, 360));
			}
			if (health < 350)
			{
				A_SpawnProjectile ("BigNeoSmoke", 0, 0, random (0, 360), 2, -random (0, 360));
				A_SpawnProjectile ("ExplosionSmoke", 0, 0, random (0, 360), 2, -random (0, 360));
			}
			if (Health < 200)
			{
				A_SpawnProjectile ("BigBlackSmoke", 40, 0, random (0, 360), 2, -random (40, 160));
			}
			if (health < 30)
			{
				A_SpawnProjectile ("FlameThrowerFireParticles", 0, 0, random (0, 360), 2, -random (0, 360));
				A_Playsound("BDFireplace2", 1, 1, 1);
				tankdeathcounter += 1;
				if (tankdeathcounter >= (35 * 5))
				{
					tankdeathcounter = 0;
					A_Die();
				}
			}
		}
	}
}


//////////////////////////////////////
// EventHandlers					//
//////////////////////////////////////

//Edit of a SpeedOMeter from Gutawer
Class SpeedoMeterHandler : EventHandler
{
	override void renderOverlay(RenderEvent e)
	{
		if(CVar.FindCVar("zm_speedometer").GetInt())
		{
			Actor mo = players[consoleplayer].mo;
			if(mo != NULL && PlayerInGame[consoleplayer])
			{
				let scalevec = statusbar.GetHUDScale();
				Vector2 scaler = (1 / scalevec.x, 1 / scalevec.y);
				Vector2 screenSize = (Screen.GetWidth() * scaler.x, Screen.GetHeight() * scaler.y);
			
				if(CVar.FindCVar("zm_speedometer").GetInt() == 2)
				{
					Vector2 drawPos = (-4 * (screenSize.x / 320), 106 * (screenSize.y / 200));
					Screen.drawText(CONFONT, Font.CR_WHITE, drawPos.x, drawPos.y, String.format("%i", mo.Vel.XY.Length() * 32), DTA_HUDRules, true);
				}
				else
				{
					Vector2 drawPos = (-4 * (screenSize.x / 320), 106 * (screenSize.y / 200));
					Screen.drawText(CONFONT, Font.CR_WHITE, drawPos.x, drawPos.y, String.format("%i", mo.Vel.XY.Length() * 10), DTA_HUDRules, true);
				}
			}
		}
	}
}

Class DashHandler : EventHandler
{
	float getPlayerAlpha()
	{
		Let DashPlayer = PlayerPawnBase(Players[consoleplayer].Mo);
		return DashPlayer.GetAlphaFade();
	}
	
	Override void renderOverlay(RenderEvent e)
	{
        Let DashPlayer = players[consoleplayer].mo;
		//TextureID dashTex = TexMan.CheckForTexture("graphics/DASHSCREEN.png",TexMan.Type_Any);
		TextureID dashTex = TexMan.CheckForTexture("DASHSCREEN",TexMan.Type_Any);
		Vector2 imageScale = TexMan.GetScaledSize(dashTex);
		
		if(DashPlayer != NULL && PlayerInGame[consoleplayer])
		{
			
			if(DashPlayer.FindInventory("PlayerDashed") && CVar.FindCVar("pb_dasheffect").GetBool() == true) {
					screen.DrawTexture (dashTex, true, 0, 0,
					DTA_HUDRULES, true,
					DTA_FULLSCREEN, true,
					DTA_SRCWIDTH, CVar.FindCVar("vid_defwidth").GetInt());
					//DTA_SRCWIDTH breaks GZ4.3.3 compatibility, a more compatible way of handling this might be useful
			}
	
		}
	}
//
    Override void NetworkProcess(ConsoleEvent e)
    {
        if(e.Player >= 0 && PlayerInGame[e.Player] && Players[e.Player].Mo)
        {
            if(e.Name == "Dash")
            {
                Let DashPlayer = PlayerPawnBase(Players[e.Player].Mo);
                if(DashPlayer) { 
					DashPlayer.DashInitiator(); 
				}
            }
        }
    }
}

Class WallSlideHandler : EventHandler
{
    Override void NetworkProcess(ConsoleEvent e)
    {
		if(!pb_wslide) { return; }
		
        if(e.Player >= 0 && PlayerInGame[e.Player] && Players[e.Player].Mo)
        {
            if(e.Name == "WallSlide")
            {
                Let WSlidePlayer = PlayerPawnBase(Players[e.Player].Mo);
                if(WSlidePlayer) { WSlidePlayer.WallSlideInitiator(); }
            }
        }
    }
}

Class GrapplingHookHandler : EventHandler
{
    Override void NetworkProcess(ConsoleEvent e)
    {
		if(!pb_hook) { return; }
		
        if(e.Player >= 0 && PlayerInGame[e.Player] && Players[e.Player].Mo)
        {
            if(e.Name == "GrapplingHook")
            {
                Let GrapplingPlayer = PlayerPawnBase(Players[e.Player].Mo);
                if(GrapplingPlayer) { GrapplingPlayer.FireHook(); }
            }
        }
    }
}

Class LedgeGrabWeapon : Weapon
{
	States
	{
		Select:
			TNT1 A 0 A_WeaponReady(WRF_NOFIRE|WRF_NOSWITCH);
			TNT1 A 0 A_Raise;
			Loop;
			
		Deselect:
			TNT1 A 0 A_WeaponReady(WRF_NOFIRE|WRF_NOSWITCH);
			TNT1 A 0 A_Lower;
			Loop;
			
		Ready:
			TNT1 A 1 A_WeaponReady(WRF_NOFIRE|WRF_NOSWITCH);
			Loop;
			
		Fire:
			TNT1 A 0 A_WeaponReady(WRF_NOFIRE|WRF_NOSWITCH);
			Stop;
	}
}

Class Hook : Actor
{
	Default
	{
		+FORCEXYBILLBOARD;
		+HITMASTER;
		+MISSILE;
		+NOGRAVITY;
		+NOTELEPORT;
		+NOTONAUTOMAP;
		+THRUSPECIES;
		Damage 6;
		Height 4;
		Radius 2;
		Speed 80;
		Species "Hook";
	}
	
	vector3 HookToPlayer;
	vector3	HookToMonster;
	int		MonsterSpeed;
	int		MonsterFloatSpeed;
	
	vector3 SafeUnit3(Vector3 VecToUnit)
	{
		if(VecToUnit.Length()) { VecToUnit /= VecToUnit.Length(); }
		return VecToUnit;
	}
	
	vector2 SafeUnit2(Vector2 VecToUnit)
	{
		if(VecToUnit.Length()) { VecToUnit /= VecToUnit.Length(); }
		return VecToUnit;
	}
	
	Override void Tick()
	{
		Let HookOwner = PlayerPawnBase(Target);
		if(HookOwner)
		{
			Vector3 WaistPos = (HookOwner.Pos.X, HookOwner.Pos.Y, HookOwner.Pos.Z + HookOwner.Height / 2.f); // player position
			HookToPlayer = Pos - WaistPos; //hook-to-player vector
		}
		
		Super.Tick();
		
		UpdateTrail();
	}
	
	void UpdateTrail()
	{
		int b;
		for(b = 1; b <= 14; b++)
		{
			ActorIterator BallOfSteele = Level.CreateActorIterator(84115 + b);
			Actor Ball = BallOfSteele.Next();
			
			if(Ball != Null)
			{
				//Set trail velocity
				Vector3 TargetPos = Pos - (HookToPlayer * b / 15.f);
				Ball.Vel = TargetPos - Ball.Pos;
			}
		}
	}
	
	void InitiateGrapple(Bool Monster)
	{
		Let HookOwner = PlayerPawnBase(Target);
		
		Float	PushLength = HookOwner.MaxGroundSpeed * pb_hookboost;
		Vector3 HookPush = SafeUnit3(HookToPlayer) * PushLength;
		Float 	HookSpeed = max((HookOwner.Vel + HookPush).Length(), PushLength);
		HookOwner.Rope = HookToPlayer; //needed for the LOS check
		
		//Check hook is still in sight
		if(!HookOwner.HookLOS())
		{
			SetState(FindState("DespawnHook"));
			return;
		}
		
		//Stop any eventual wall slides
		HookOwner.StopWSlide();
		
		//Stop dashing stuff
		HookOwner.ADashCooler = HookOwner.ADashTargetSpeed = 0;
		
		//Initiate hook
		HookSpeed = HookOwner.MaxAirSpeed = min(HookSpeed, pb_maxhopspeed);
		HookOwner.Vel = HookOwner.GrappleVel = HookSpeed * SafeUnit3(HookPush);
		
		//Hooking monsters specific
		if(Monster)
		{
			Let Monster = Actor(Master);
			PlayerPawnBase(Target).GrappledMonster = Monster;
			SetMonsterSpeed(False);
			A_PlaySound("HookMeat", 7);
		}
		else
		{
			A_PlaySound("HookWall", 7);
		}
	}
	
	void SetMonsterSpeed(Bool Reset)
	{
		Let Monster = Actor(Master);
		
		if(!Reset)
		{
			MonsterSpeed = Monster.Speed;
			MonsterFloatSpeed = Monster.FloatSpeed;
			Monster.Speed = Monster.FloatSpeed = 0;
		}
		else
		{
			Monster.Speed = MonsterSpeed;
			Monster.FloatSpeed = MonsterFloatSpeed;
		}
	}
	
	void SpawnTrail()
	{
		int h;
		for(h = 1; h <= 14; h++)
		{
			A_SpawnItemEx("HookTrail",0,0,0,0,0,0,0,SXF_ISTRACER|SXF_SETTARGET|SXF_ORIGINATOR|SXF_NOCHECKPOSITION);
			
			Let SlaveTrail = HookTrail(Tracer);
			SlaveTrail.ChangeTid(84115 + h);
		}
	}
	
	States
	{
	//////////////////////////////////////
	//Hook is traveling through space
	Spawn:
		OCLW A 0 NoDelay
		{
			A_AlertMonsters();
			SpawnTrail();
		}
	Looper:
		OCLW A 1
		{
			Let HookOwner = PlayerPawnBase(Target);
			//Despawn if no geometry was found
			if(HookToPlayer.Length() >= 1000.f || !HookOwner)
			{
				SetState(FindState("DespawnHook"));
				return;
			}
		}
		Loop;
	
	//////////////////////////////////////
	//Hook hit a wall or ceiling
	Death:
		OCLW A 0
		{
			Let HookOwner = PlayerPawnBase(Target);
			if(!HookOwner)
			{
				SetState(FindState("DespawnHook"));
				return;
			}
			
			InitiateGrapple(False);
		}
	
	TillDeathDoesUsApart:
		OCLW A 1
		{
			Let HookOwner = PlayerPawnBase(Target);
			if(!HookOwner.GrappleVel.Length() || !HookOwner)
			{
				SetState(FindState("DespawnHook"));
				return;
			}
			
			HookOwner.Rope = HookToPlayer;
		}
		Loop;
		
	//////////////////////////////////////
	//Hit actor
	XDeath:
		OCLW A 0
		{
			Let Monster = Actor(Master);
			if(!Monster.bISMONSTER)
			{
				SetState(FindState("DespawnHook"));
				return;
			}
			
			InitiateGrapple(True);
		}
	
	TillXDeathDoesUsApart:
		OCLW A 1
		{
			Let HookOwner = PlayerPawnBase(Target);
			Let Monster = Actor(Master);
			
			if(!HookOwner.GrappleVel.Length() || !HookOwner || Monster.Health <= 0)
			{
				SetState(FindState("DespawnHook"));
				return;
			}
			
			Vel = Monster.Vel;
			HookOwner.Rope = HookToPlayer;
		}
		Loop;
		
	//////////////////////////////////////
	//Die Monster! You don't belong in this world
	DespawnHook:
		OCLW A 0
		{
			Let HookOwner = PlayerPawnBase(Target);
			if(HookOwner)
			{
				HookOwner.StopHook();
				HookOwner.A_PlaySound("HookFailed", 7, 0.2);
			}
			
			Let Monster = Actor(Master);
			if(Monster && MonsterSpeed) { SetMonsterSpeed(True); }
		}
		Stop;
	}
}

Class HookTrail : Actor
{
	Default
	{
		+FORCEXYBILLBOARD;
		+MISSILE;
		+NOGRAVITY;
		+NOTELEPORT;
		+NOTONAUTOMAP;
		+THRUSPECIES;
		Radius 2;
		Height 4;
		Scale 0.5;
		Species "HookTrail";
	}
	
	States
	{
		Spawn:
		Looper:
			TEND A 1
			{
				if(!Hook(Target))
				{
					SetState(FindState("DespawnTrail"));
					return;
				}
			}
			Loop;
			
		Death:
			TEND A 1
			{
				if(!Hook(Target))
				{
					SetState(FindState("DespawnTrail"));
					return;
				}
			}
			Loop;
			
		DespawnTrail:
			Stop;
	}
}