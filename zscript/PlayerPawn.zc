class PlayerPawnBase : PlayerPawn
{
	bool IsTank;
	Property IsTank : IsTank;
	int tankdeathcounter;
	int tankspritecounter;
	bool baseweaponpda;
	TankBaseNotReal TankBaseSprite; //tank's fake sprite as the actor.
	Actor TankTurretSprite;
	string TankTurretSpriteActor;
	Property TankTurretSpriteActor: TankTurretSpriteActor;
	Array<String> CollectedWeapons, BaseWeapons;
	
	//ZMovement 2.0
	//Movement General
	vector2	MoveVec;
	bool	StrafeRunning;
	bool	Pain;
	double 	MaximumGroundSpeed;
	double	MaximumHopSpeed;
	int		Penalizer;
	
	//////////////////
	
	//Jumping
	bool 	BlockJump;
	bool	Jumping;
	bool	ZMJumpTics;
	int		JumpSoundCooler;
	
	//Double Jump
	bool	BlockDoubleJump;
	bool	CanDoubleJump;
	
	//Ramp Jumps
	bool	UpStairs;
	double	OldFloor;
	
	//Elevator Jumps
	double	ElevatorJumpBoost;
	double	OldSecZ;
	int		OldSecIndex;
	
	//Landing Animation
	double	ZDeltaViewHeight;
	double	OldPosZ;
	
	//////////////////
	
	//Double Tap
	int		FirstTapTime;
	int		FirstTapValue;
	int		OldTapValue;
	
	//Dashing - WallJumping / Sliding
	vector2	SlideVelocity;
	bool	CanDash;
	bool	CanChainJump;
	bool	CanWallSlide;
	double	DashSpeed;
	double	MaxDashLength;
	double	SlideSpeed;
	int		CheckForWSlide;
	int		CheckForWallJump;
	int		DashCooler;
	int		DashNumber;
	int		DashRecovery;
	
	//Crouch Slide
	bool	CanCSlide;
	double	CSlideVelocity;
	double	MaximumSlideSpeed;
	int		CSlideStartTime;
	int		QSlideDuration;
	bool	CSlideStarted;
	int		SlideCooler;
	
	//Bobbing
	bool	CenterAligned;
	bool	HoppingBob;
	double	BobFactor;
	double	MoveFakeTime;
	double	XBob;
	double	XBobOffset;
	double	YBob;
	int		BobType;
	int		PreviousTic;
	int		StillFakeTime;
	
	///////////////////////////////////
	// Dusk Only
	int		OldMoveVecAngle;
	
	///////////////////////////////////
	//Painkiller only
	
	//Movement
	float	PKAirControl;
	
	//Jumping
	double	TrickJumpAngle;
	int		SmallerJumpHeight;
	
	///////////////////////////////////
	//Build Engine Only
	
	//Jumping
	int		BuildJumpDelay;
	
	Default
    {
		+NOFRICTION;
		Player.DisplayName "ZMovement Player";
        PainChance 255;
    }
	
	////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////
	////																						////
	//// Non-Movement Stuff																		////
	////																						////
	////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////
	
	Override void PlayerThink()
	{
		let player = self.player;
		UserCmd cmd = player.cmd;
			
		Player.OnGround = Pos.Z <= FloorZ || bONMOBJ || bMBFBOUNCER || (Player.Cheats & CF_NOCLIP2);
		
		//Set some basic parameters
		Jumping = (cmd.buttons & BT_JUMP) && !BlockJump;
		Gravity = zm_setgravity;
		StrafeRunning = cmd.forwardmove && cmd.sidemove;
		MaximumGroundSpeed = zm_topgroundspeed * Speed * (Straferunning && Player.OnGround ? zm_strafemodifier : 1);
		Pain = InStateSequence(CurState, FindState("Pain"));
		
		//Dashing cooler
		if(DashCooler) { DashCooler--; }
		
		CheckFOV();
		
		if (player.inventorytics)
		{
			player.inventorytics--;
		}
		CheckCheats();

		if(bJustAttacked)
		{
			cmd.yaw = 0;
			cmd.forwardmove = 0xc800/2;
			cmd.sidemove = 0;
			bJustAttacked = false;
		}

		bool totallyfrozen = CheckFrozen();
		
		CheckCrouch(totallyfrozen);
		CheckMusicChange();

		if(player.playerstate == PST_DEAD)
		{
			DeathThink ();
			return;
		}
		
		if (player.morphTics && !(player.cheats & CF_PREDICTING))
		{
			MorphPlayerThink ();
		}

		CheckPitch();
		CalcHeight();
		HandleMovement();

		if (!(player.cheats & CF_PREDICTING))
		{
			CheckEnvironment();

			player.mo.CheckUse();
			player.mo.CheckUndoMorph();
			
			player.mo.TickPSprites();
			
			if (player.damagecount)	player.damagecount--;
			if (player.bonuscount) player.bonuscount--;

			if (player.hazardcount)
			{
				player.hazardcount--;
				if (!(Level.maptime % player.hazardinterval) && player.hazardcount > 16*TICRATE)
					player.mo.DamageMobj (NULL, NULL, 5, player.hazardtype);
			}
			player.mo.CheckPoison();
			player.mo.CheckDegeneration();
			player.mo.CheckAirSupply();
		}
	}
	
	Override void CalcHeight()
	{
		let player = self.player;
		double angle;
		double bob;
		bool still = false;

		if(player.cheats & CF_NOCLIP2)
		{
			player.bob = 0;
		}
		else if(bNoGravity && !player.onground)
		{
			player.bob = 0.5;
		}
		else
		{
			player.bob = Vel dot Vel;
			if(player.bob == 0)
			{
				still = true;
			}
			else
			{
				player.bob *= player.GetMoveBob();

				if (player.bob > MAXBOB)
					player.bob = MAXBOB;
			}
		}

		double defaultviewheight = ViewHeight + player.crouchviewdelta;

		if (player.cheats & CF_NOVELOCITY)
		{
			player.viewz = pos.Z + defaultviewheight;

			if (player.viewz > ceilingz-4)
				player.viewz = ceilingz-4;

			return;
		}

		if(still)
		{
			if(player.health > 0)
			{
				angle = Level.maptime / (120 * TICRATE / 35.) * 360.;
				bob = player.GetStillBob() * sin(angle);
			}
			else
			{
				bob = 0;
			}
		}
		else
		{
			angle = Level.maptime / (20 * TICRATE / 35.) * 360.;
			bob = player.bob * sin(angle) * (waterlevel > 1 ? 0.25f : 0.5f);
		}
		
		if(player.morphTics) { bob = 0; }
		
		//////////////////////////////////////////////////////
		// Customizable Landing
		
		if(zm_landing || !zm_airmovetype)
		{
			if(Player.OnGround && Pos.Z - OldPosZ < 0)
				ZDeltaViewHeight = (Pos.Z - OldPosZ) / zm_landingsens;
			
			if(player.playerstate == PST_LIVE)
			{
				player.viewheight += ZDeltaViewHeight;

				if(player.viewheight > defaultviewheight)
				{
					player.viewheight = defaultviewheight;
					ZDeltaViewHeight = 0;
				}
				else if(player.viewheight < defaultviewheight && !BuildJumpDelay)
				{
					player.viewheight = max(player.viewheight, defaultviewheight * zm_minlanding);
					ZDeltaViewHeight += zm_landingspeed;
				}
				else
				{
					ZDeltaViewHeight = 0;
				}
			}
		}
		else //regular Doom landing
		{
			if (player.playerstate == PST_LIVE)
			{
				player.viewheight += player.deltaviewheight;

				if (player.viewheight > defaultviewheight)
				{
					player.viewheight = defaultviewheight;
					player.deltaviewheight = 0;
				}
				else if (player.viewheight < (defaultviewheight/2))
				{
					player.viewheight = defaultviewheight/2;
					if (player.deltaviewheight <= 0)
						player.deltaviewheight = 1 / 65536.;
				}
				
				if (player.deltaviewheight)	
				{
					player.deltaviewheight += 0.25;
					if (!player.deltaviewheight)
						player.deltaviewheight = 1/65536.;
				}
			}
		}
			
		//Let's highlight the important stuff shall we?
		player.viewz = pos.Z + player.viewheight + (bob * clamp(ViewBob, 0. , 1.5));
		
		if(Floorclip && player.playerstate != PST_DEAD && pos.Z <= floorz) { player.viewz -= Floorclip; }
		if(player.viewz > ceilingz - 4) { player.viewz = ceilingz - 4; }
		if(player.viewz < floorz + 4) { player.viewz = floorz + 4; }
		
		OldPosZ = Pos.Z;
	}
	
	Override void CheckPitch()
	{
		let player = self.player;
		
		int clook = player.cmd.pitch;
		if (clook != 0)
		{
			if (clook == -32768)
			{
				player.centering = true;
			}
			else if (!player.centering)
			{
				A_SetPitch(Pitch - clook * (360. / 65536.), SPF_INTERPOLATE);
			}
		}
		
		if (player.centering)
		{
			if (abs(Pitch) > 2.)
			{
				Pitch *= (2. / 3.);
			}
			else
			{
				Pitch = 0.;
				player.centering = false;
				if (PlayerNumber() == consoleplayer)
				{
					LocalViewPitch = 0;
				}
			}
		}
	}
	
	////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////
	////																						////
	//// Movement Stuff																			////
	////																						////
	////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////
	
	Override void HandleMovement()
	{
		let player = self.player;
		UserCmd cmd = Player.cmd;
		
		// [RH] Check for fast turn around
		if (player.cmd.buttons & BT_TURN180 && !(player.oldbuttons & BT_TURN180))
		{
			player.turnticks = TURN180_TICKS;
		}

		// Handle movement
		if(reactiontime)
		{ // Player is frozen
			reactiontime--;
		}
		else
		{
			if(Player.TurnTicks) //moved here to save many doubled lines
			{
				Player.TurnTicks--;
				A_SetAngle(Angle + (180.0 / TURN180_TICKS), SPF_INTERPOLATE);
			}
			else
				A_SetAngle(Angle + cmd.Yaw * (360.0 / 65536.0), SPF_INTERPOLATE);
			
			if(WaterLevel >= 2)
			{
				WaterMovePlayer();
			}
			else if(bNOGRAVITY)
			{
				FlyMovePlayer();
			}
			else if(CanCSlide)
			{
				if(zm_cslidetype)
					QSlideMovePlayer();
				else
					CSlideMovePlayer();
			}
			else if(Player.OnGround && !Jumping)
			{
				if(CanDash)
				{
					if(zm_airmovetype == 3)
						QDashMovePlayer();
					else
						DashMovePlayer();
				}
				else
				{
					if(zm_groundmovetype)
						QuakeGroundMove();
					else
						DoomGroundMove();
				}
			}
			else
			{
				if(CanDash || CanWallSlide)
				{
					if(zm_airmovetype == 3)
						QDashMovePlayer();
					else
						DashMovePlayer();
				}
				
				if(!CanDash && !CanWallSlide)
				{
					if(!zm_airmovetype)
						BuildAirMove();
					else if(zm_airmovetype == 1)
						DuskAirMove();
					else if(zm_airmovetype == 2)
						PainkillerAirMove();
					else if (zm_airmovetype == 3)
						QuakeAirMove();
					else if(zm_airmovetype)
						UTAirMove();
				}
			}
			
			/////////////////////////////////////////
			//moved here to save many doubled lines
			Double 	Friction, MoveFactor;
			[Friction, MoveFactor] = GetFriction();
			BobFactor = Friction < ORIG_FRICTION ? MoveFactor : ORIG_FRICTION_FACTOR;
			
			if(cmd.forwardmove)
				Bob(Angle, cmd.forwardmove * bobfactor / 256., true);
			if(cmd.sidemove)
				Bob(Angle - 90, cmd.sidemove * bobfactor / 256., false);
			
			If (Player.Cheats & CF_REVERTPLEASE != 0)
			{
				Player.Cheats &= ~CF_REVERTPLEASE;
				Player.Camera = Player.Mo;
			}
			/////////////////////////////////////////
			
			if(!zm_airmovetype)
				BuildJump();
			else if(zm_airmovetype == 2)
				PainkillerJump();
			else
				CheckJump();
			
			CheckMoveUpDown();
		}
	}
	
	//////////////////////////////////////////
	// Jumping								//
	//////////////////////////////////////////
	
	Override void CheckJump()
	{
		let player = self.player;
		
		//Jump Sound Cooler
		if(JumpSoundCooler) { JumpSoundCooler--; }
		
		//Double Jump
		if(Player.OnGround) { CanDoubleJump = True; }
		
		//Regular Jumping && Ramp Jumps
		if(ZMJumpTics && (WaterLevel >= 2 || bNOGRAVITY || Player.OnGround)) { ZMJumpTics = False; }
		
		//Elevators Jump Boost
		Sector 	Sec = CurSector;
		Int 	SecIndex = Sec.Index();
		Double	SecZ = GetZAt(0,0);
		
		if(Player.OnGround && SecIndex == OldSecIndex && SecZ > OldSecZ)
		{
			if(zm_elevatorjump)
				ElevatorJumpBoost = (SecZ - OldSecZ) * zm_ejumpmultiplier;
			else
				BlockJump = True;
		}
		else
		{
			if(zm_elevatorjump) { ElevatorJumpBoost = 0; }
		}
			
		OldSecZ = SecZ;
		OldSecIndex = SecIndex;
		
		/////////////////////////////////////
		
		if(player.cmd.buttons & BT_JUMP)
		{
			if (player.crouchoffset != 0)
			{
				player.crouching = 1;
			}
			else if(WaterLevel >= 2)
			{
				Vel.Z = clamp(Vel.Z + 12800 * Speed / 256, - MaximumGroundSpeed / 2., MaximumGroundSpeed / 2.);
			}
			else if(bNOGRAVITY)
			{
				Vel.Z = clamp(Vel.Z + 12800 * Speed / 256, - (MaximumGroundSpeed * 3.) / 2.,(MaximumGroundSpeed * 3.) / 2);
			}
			else if(player.onground && !BlockJump)
			{
				double jumpvelz = zm_jumpheight + ElevatorJumpBoost;
				double jumpfac = 0;
				
				for (let p = Inv; p != null; p = p.Inv)
				{
					let pp = PowerHighJump(p);
					if (pp)
					{
						double f = pp.Strength;
						if (f > jumpfac) jumpfac = f;
					}
				}
				if (jumpfac > 0) jumpvelz *= jumpfac;
				
				if(Pos.Z > OldFloor)
					UpStairs = True;
				else
					UpStairs = False;
				
				if(zm_rampjump)
					Vel.Z += jumpvelz;
				else
					Vel.Z = jumpvelz;
				
				bOnMobj = false;
				ZMJumpTics = True;
				OldFloor = Pos.Z;
				
				if(!(player.cheats & CF_PREDICTING) && !JumpSoundCooler)
				{
					A_PlaySound("*jump", CHAN_BODY);
					JumpSoundCooler = 4;
				}
				
				//If autojump is on set Blockjump false while jump key is pressed
				BlockJump = zm_autojump ? False : True;
				BlockDoubleJump = True;
			}
			else if(!Player.OnGround && CanDoubleJump && !BlockDoubleJump && ((zm_doublejump == 1 && Vel.Z > 0) || zm_doublejump == 2))
			{
				double doublejumpvelz = zm_jumpheight * zm_doublejumpheight ;
				double jumpfac = 0;

				for (let p = Inv; p != null; p = p.Inv)
				{
					let pp = PowerHighJump(p);
					if (pp)
					{
						double f = pp.Strength;
						if (f > jumpfac) jumpfac = f;
					}
				}
				if (jumpfac > 0) doublejumpvelz *= jumpfac;
				
				Vel.Z = doublejumpvelz;
				
				bOnMobj = false;
				ZMJumpTics = True;
				
				if(!(player.cheats & CF_PREDICTING)) { A_PlaySound("JMPBOOT", CHAN_BODY); }
				
				CanDoubleJump = False;
			}
		}
		else
		{
			if((zm_airmovetype == 4 && Player.OnGround) || zm_airmovetype != 4) { BlockJump = False; }
			BlockDoubleJump = False;
		}
	}
	
	Virtual void BuildJump()
	{
		//Jump Sound Cooler
		if(JumpSoundCooler) { JumpSoundCooler--; }
		
		//Double Jump
		if(Player.OnGround) { CanDoubleJump = True; }
		
		//Regular Jumping && Ramp Jumps
		if(ZMJumpTics && (WaterLevel >= 2 || bNOGRAVITY || Player.OnGround)) { ZMJumpTics = False; }
		
		//Elevators Jump Boost
		Sector 	Sec = CurSector;
		Int 	SecIndex = Sec.Index();
		Double	SecZ = GetZAt(0,0);
		
		if(Player.OnGround && SecIndex == OldSecIndex && SecZ > OldSecZ)
		{
			if(zm_elevatorjump)
				ElevatorJumpBoost = (SecZ - OldSecZ) * zm_ejumpmultiplier;
			else
				BlockJump = True;
		}
		else
		{
			if(zm_elevatorjump) { ElevatorJumpBoost = 0; }
		}
			
		OldSecZ = SecZ;
		OldSecIndex = SecIndex;
		
		/////////////////////////////////////
		
		if(player.cmd.buttons & BT_JUMP || BuildJumpDelay)
		{
			if(player.crouchoffset != 0)
			{
				player.crouching = 1;
			}
			else if(WaterLevel >= 2)
			{
				Vel.Z = clamp(Vel.Z + 12800 * Speed / 256, - MaximumGroundSpeed / 2., MaximumGroundSpeed / 2.);
			}
			else if(bNOGRAVITY)
			{
				Vel.Z = clamp(Vel.Z + 12800 * Speed / 256, -(MaximumGroundSpeed * 3.) / 2.,(MaximumGroundSpeed * 3.) / 2);
			}
			else if(player.onground && !BlockJump)
			{
				Double BuildSmallerJump;
				
				if(ZDeltaViewHeight)
				{
					BuildSmallerJump = 0.85;
				}
				else
				{
					if(!BuildJumpDelay)
					{
						BuildJumpDelay = 4;
						return;
					}
						
					if(BuildJumpDelay > 2)
						player.viewheight -= be_jumpanim;	
					else
						player.viewheight += be_jumpanim;
					
					if(BuildJumpDelay)
					{
						BuildJumpDelay--;
						if(BuildJumpDelay) { return; }
					}
					
					BuildSmallerJump = 1.;
				}
				
				double jumpvelz = zm_jumpheight + ElevatorJumpBoost;
				double jumpfac = 0;
				
				for (let p = Inv; p != null; p = p.Inv)
				{
					let pp = PowerHighJump(p);
					if (pp)
					{
						double f = pp.Strength;
						if (f > jumpfac) jumpfac = f;
					}
				}
				if (jumpfac > 0) jumpvelz *= jumpfac;
				
				if(zm_rampjump)
					Vel.Z += jumpvelz * BuildSmallerJump;
				else
					Vel.Z = jumpvelz * BuildSmallerJump;
						
				bOnMobj = false;
				ZMJumpTics = True;
				OldFloor = Pos.Z;
						
				if(!(player.cheats & CF_PREDICTING) && !JumpSoundCooler)
				{
					A_PlaySound("*jump", CHAN_BODY);
					JumpSoundCooler = 4;
				}
				
				BlockJump = zm_autojump ? False : True;
				BlockDoubleJump = True;
			}
			else if(!Player.OnGround)
			{
				if(BuildJumpDelay)
				{
					BuildJumpDelay = 0;
					ZDeltaViewHeight = False;
				}
				
				if(CanDoubleJump && !BlockDoubleJump && ((zm_doublejump == 1 && Vel.Z > 0) || zm_doublejump == 2))
				{
					double doublejumpvelz = zm_jumpheight * zm_doublejumpheight ;
					double jumpfac = 0;

					for (let p = Inv; p != null; p = p.Inv)
					{
						let pp = PowerHighJump(p);
						if (pp)
						{
							double f = pp.Strength;
							if (f > jumpfac) jumpfac = f;
						}
					}
					if (jumpfac > 0) doublejumpvelz *= jumpfac;
					
					Vel.Z = doublejumpvelz;
					
					bOnMobj = false;
					ZMJumpTics = True;
					
					if(!(player.cheats & CF_PREDICTING)) { A_PlaySound("*jump", CHAN_BODY); }
					
					CanDoubleJump = False;
				}
			}
		}
		else
		{
			BlockDoubleJump = False;
			if(Player.OnGround) { BlockJump = False; }
		}
	}
	
	Virtual void PainkillerJump()
	{
		let player = self.player;
		
		//Jump Sound Cooler
		if(JumpSoundCooler) { JumpSoundCooler--; }
		
		//Double Jump
		if(Player.OnGround) { CanDoubleJump = True; }
		
		//Regular Jumping && Ramp Jumps
		if(ZMJumpTics && (WaterLevel >= 2 || bNOGRAVITY || Player.OnGround)) { ZMJumpTics = False; }
		
		//Elevators Jump Boost
		Sector 	Sec = CurSector;
		Int 	SecIndex = Sec.Index();
		Double	SecZ = GetZAt(0,0);
		
		if(Player.OnGround && SecIndex == OldSecIndex && SecZ > OldSecZ)
		{
			if(zm_elevatorjump)
				ElevatorJumpBoost = (SecZ - OldSecZ) * zm_ejumpmultiplier;
			else
				BlockJump = True;
		}
		else
		{
			if(zm_elevatorjump) { ElevatorJumpBoost = 0; }
		}
			
		OldSecZ = SecZ;
		OldSecIndex = SecIndex;
		
		/////////////////////////////////////
		
		if(player.cmd.buttons & BT_JUMP)
		{
			if (player.crouchoffset != 0)
			{
				player.crouching = 1;
			}
			else if(WaterLevel >= 2)
			{
				Vel.Z = clamp(Vel.Z + 12800 * Speed / 256, - MaximumGroundSpeed / 2., MaximumGroundSpeed / 2.);
			}
			else if(bNOGRAVITY)
			{
				Vel.Z = clamp(Vel.Z + 12800 * Speed / 256, -(MaximumGroundSpeed * 3.) / 2.,(MaximumGroundSpeed * 3.) / 2);
			}
			else if(player.onground && !BlockJump)
			{
				SmallerJumpHeight++;
				
				double jumpvelz = zm_jumpheight + ElevatorJumpBoost;
				double jumpfac = 0;
				
				for (let p = Inv; p != null; p = p.Inv)
				{
					let pp = PowerHighJump(p);
					if (pp)
					{
						double f = pp.Strength;
						if (f > jumpfac) jumpfac = f;
					}
				}
				if (jumpfac > 0) jumpvelz *= jumpfac;
				
				if(Pos.Z > OldFloor)
					UpStairs = True;
				else
					UpStairs = False;
				
				if(zm_rampjump)
				{
					if(Penalizer)
						Vel.Z += jumpvelz * 0.5;
					else
						Vel.Z += SmallerJumpHeight > 1 ? jumpvelz * pk_bhopjumpheight : jumpvelz;
				}
				else
				{
					if(Penalizer)
						Vel.Z = jumpvelz * 0.5;
					else
						Vel.Z = SmallerJumpHeight > 1 ? jumpvelz * pk_bhopjumpheight : jumpvelz;
				}
				
				bOnMobj = false;
				ZMJumpTics = True;
				OldFloor = Pos.Z;
				
				if(!(player.cheats & CF_PREDICTING) && !JumpSoundCooler)
				{
					A_PlaySound("*jump", CHAN_BODY);
					JumpSoundCooler = 4;
				}
				
				//If autojump is on set Blockjump false while jump key is pressed
				BlockJump = zm_autojump ? False : True;
				BlockDoubleJump = True;
			}
			else if(!Player.OnGround && CanDoubleJump && !BlockDoubleJump && ((zm_doublejump == 1 && Vel.Z > 0) || zm_doublejump == 2))
			{
				double doublejumpvelz = zm_jumpheight * zm_doublejumpheight ;
				double jumpfac = 0;

				for (let p = Inv; p != null; p = p.Inv)
				{
					let pp = PowerHighJump(p);
					if (pp)
					{
						double f = pp.Strength;
						if (f > jumpfac) jumpfac = f;
					}
				}
				if (jumpfac > 0) doublejumpvelz *= jumpfac;
				
				Vel.Z = doublejumpvelz;
				
				bOnMobj = false;
				ZMJumpTics = True;
				
				if(!(player.cheats & CF_PREDICTING)) { A_PlaySound("*jump", CHAN_BODY); }
				
				CanDoubleJump = False;
			}
		}
		else
		{
			BlockJump = False;
			BlockDoubleJump = False;
		}
	}
	
	//////////////////////////////////////////
	// Ground Movement						//
	//////////////////////////////////////////
	
	Virtual float ZMScale()
	{
		Let Player = self.Player;
		UserCmd cmd = player.cmd;
		
		Bool 	IsWalking = (CVar.GetCVar("cl_run", Player).GetBool() && (cmd.buttons & BT_SPEED)) || (!CVar.GetCVar("cl_run", Player).GetBool() && !(cmd.buttons & BT_SPEED));
		Float 	MoveMulti;
		
		if(Player.CrouchFactor == 0.5 && !CanCSlide)
		{
			MoveMulti = min(zm_crouchspeed, zm_walkspeed);
			BobFactor *= min(zm_crouchspeed, zm_walkspeed);
		}
		else if(IsWalking)
		{
			MoveMulti = zm_walkspeed;
		}
		else
		{
			MoveMulti = 1;
		}

		if (!player.morphTics)
		{
			double factor = 1.;
			for(let it = Inv; it != null; it = it.Inv)
			{
				factor *= it.GetSpeedFactor ();
			}
			MoveMulti *= factor;
		}
		
		return MoveMulti;
	}
	
	//////////////////////////////////////////
	// Quake
	
	Virtual void QFriction(float StopSpeed, float Friction)
	{
		Double Speed = Vel.XY.Length();
		if(Speed < 1.)
		{
			Vel.XY = (0, 0);
			return;
		}
		
		Double Drop, Control;
		if(WaterLevel >= 2)
		{
			drop = Speed * Friction / TICRATE; //very tight friction
		}
		else if(bNOGRAVITY)
		{
			drop = Speed * Friction / TICRATE; //loose friction
		}
		else if(WaterLevel < 2 && Player.OnGround)
		{
			Control = Speed < StopSpeed ? zm_friction : Speed;
			Drop = Control * Friction / TICRATE;
		}
		
		Double NewSpeed = (Speed - Drop <= 0 ? 0 : Speed - Drop) / Speed;
		Vel *= NewSpeed;
	}
	
	Virtual void QAcceleration(Vector3 WishDir, Float WishSpeed, Float Accel)
	{
		Float CurrentSpeed = WishDir dot Vel;
		Float AddSpeed = WishSpeed - CurrentSpeed;
		if(AddSpeed <= 0) { return; }
		
		Float AccelerationSpeed = Accel * WishSpeed / 35.;
		if(AccelerationSpeed > AddSpeed) { AccelerationSpeed = AddSpeed; }
		Vel += AccelerationSpeed * WishDir;
	}
	
	Virtual void QuakeGroundMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		//Crouchslide
		if(zm_crouchslide)
		{
			CSlideInitiator();
			if(CanCSlide)
			{
				if(zm_cslidetype)
					QSlideMovePlayer();
				else
					CSlideMovePlayer();
				return;
				
			}
			else
			{
				QSlideDuration = 0;
			}
		}
		
		//Dashing / WallSliding
		if(CVar.GetCVar("zm_doubletap", Player).GetBool())
		{
			DoubleTapCheck();
			if(CanDash || CanWallSlide)
			{
				DashMovePlayer();
				return;
			}
		}
		
		///////////////////////////////////////////
		//Actual Movement
		MoveVec = RotateVector((cmd.forwardmove, - cmd.sidemove), Angle);
		MaximumHopSpeed = Vel.XY.Length();
		
		if(DashRecovery)
		{
			DashRecovery--;
			Vel.XY *= 0.5;
		}
		else
		{
			//Values Reset
			Penalizer = 0;
			SmallerJumpHeight = 0;
			PKAirControl = 1;
			//Friction
			QFriction(MaximumGroundSpeed, 6.0);
			//Acceleration
			if(MoveVec.Length()) { QAcceleration((MoveVec.Unit(), 0), MaximumGroundSpeed * ZMScale(), 10.0f); }
		}
		
		// Sprite Animation
		If(Player.Cheats & CF_PREDICTING == 0 && Vel.XY.Length() > 1)
			PlayRunning();
		else
			PlayIdle();
	}
	
	//////////////////////////////////////////
	// Doom
	
	Virtual void DoomFriction()
	{
		Double DFriction = zm_friction / 20;
		MoveVec *= DFriction * 15;
		if(Vel.XY.Length() < 1)
			Vel.XY = (0, 0);
		else
			Vel.XY *= 1 - DFriction;
	}
	
	Virtual void DoomGroundMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		//Crouchslide
		if(zm_crouchslide)
		{
			CSlideInitiator();
			if(CanCSlide)
			{
				if(zm_cslidetype)
					QSlideMovePlayer();
				else 
					CSlideMovePlayer();
				return;
			}
			else
			{
				QSlideDuration = 0;
			}
		}
		
		//Dashing / WallSliding
		if(CVar.GetCVar("zm_doubletap", Player).GetBool())
		{
			DoubleTapCheck();
			if(CanDash || CanWallSlide)
			{
				DashMovePlayer();
				return;
			}
		}
		
		MoveVec = RotateVector((cmd.forwardmove, - cmd.sidemove), Angle);
		MaximumHopSpeed = Vel.XY.Length();
		
		///////////////////////////////////////////
		//Actual Movement
		if(DashRecovery)
		{
			DashRecovery--;
			Vel.XY *= 0.5;
		}
		else
		{
			//Values Reset
			Penalizer = 0;
			SmallerJumpHeight = 0;
			PKAirControl = 1;
			
			Float Scaler = ZMScale();
			if(MoveVec.Length()) { MoveVec = MoveVec.Unit() * Speed * Scaler * (Straferunning ? zm_strafemodifier : 1); }
			//Friction
			DoomFriction();
			//Acceleration, we need to normalize to allow proper base speed customization
			if((Vel.XY + MoveVec).Length() > MaximumGroundSpeed * Scaler)
				Vel.XY = (Vel.XY + MoveVec).Unit() * MaximumGroundSpeed * Scaler;
			else
				Vel.XY += MoveVec;
		}
		
		// Sprite Animation
		If(Player.Cheats & CF_PREDICTING == 0 && Vel.XY.Length() > 1)
			PlayRunning();
		else
			PlayIdle();
	}
	
	//////////////////////////////////////
	// Flying							//
	//////////////////////////////////////
	
	Virtual void FlyMovePlayer()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		MoveVec = (cmd.sidemove, cmd.forwardmove);
		if(MoveVec.Length()) { MoveVec = MoveVec.Unit() * 4 * Speed * ZMScale() * (Straferunning ? zm_strafemodifier : 1); }
		
		//This is not needed for the purpose of FlyMovePlayer() but is necessary to make sure PainkillerMovePlayer() does not glitch out after coming out of water
		MaximumHopSpeed = Vel.XY.Length();
		Penalizer = 0;
		SmallerJumpHeight = 0;
		
		///////////////////////////////////////////
		//Actual Movement
		
		//Friction
		QFriction(0, 2.0);
		//Vertical
		Vel.Z += MoveVec.Y * sin(-Pitch);
		//Horizontal
		MoveVec.Y *= cos(Pitch);
		//Add to Velocity
		if(!(cmd.buttons & BT_JUMP)) { Vel.XY += RotateVector(MoveVec, Angle - 90); }
		//Speed normalizer (this way your speed does not increase when you move at an angle)
		if(abs(Vel.Z) + Vel.XY.Length() > (MaximumGroundSpeed * 3) / 2. && (cmd.sidemove || cmd.forwardmove))
			Vel = (MaximumGroundSpeed * 3.) / 2. * Vel.Unit();
			
		//Negate crouchslide after stopping flying
		if(zm_crouchslide) { CSlideInitiator(); }
		
		// Sprite Animatiom
		PlayIdle();
	}
	
	//////////////////////////////////////
	// Water							//
	//////////////////////////////////////
	
	Virtual void WaterMovePlayer()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		MoveVec = (cmd.sidemove, cmd.forwardmove);
		if(MoveVec.Length()) { MoveVec = MoveVec.Unit() * 4 * Speed * ZMScale() * (Straferunning ? zm_strafemodifier : 1); }
		
		//This is not needed for the purpose of WaterMovePlayer() but is necessary to make sure Painkiller and Dusk do not glitch out after coming out of water
		MaximumHopSpeed = Vel.XY.Length();
		Penalizer = 0;
		SmallerJumpHeight = 0;
		
		///////////////////////////////////////////
		//Actual Movement
		
		//Friction
		QFriction(0, 10.0);
		//Vertical
		Vel.Z += MoveVec.Y * sin(-Pitch);
		//Horizontal
		MoveVec.Y *= cos(Pitch);
		//Add to velocity
		if(!(cmd.buttons & BT_JUMP)) { Vel.XY += RotateVector(MoveVec, Angle - 90); }
		//Speed normalizer (this way your speed does not increase when you move at an angle)
		if(Vel.Length() > MaximumGroundSpeed / 2. && (cmd.sidemove || cmd.forwardmove))
			Vel = MaximumGroundSpeed / 2. * Vel.Unit();
		
		//Negate crouchslide coming out of water
		if(zm_crouchslide) { CSlideInitiator(); }
		
		// Sprite Animation
		If(Player.Cheats & CF_PREDICTING == 0 && Vel.XY.Length() > 1)
			PlayRunning();
		else
			PlayIdle();
	}
	
	//////////////////////////////////////
	// Air Movement						//
	//////////////////////////////////////
	
	//////////////////////////////////////
	// Build Engine
	
	Virtual void BuildAirMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		MoveVec = RotateVector((cmd.forwardmove, - cmd.sidemove), Angle);
		
		///////////////////////////////////////////
		//Dashing / Crouch Slide
		if(CVar.GetCVar("zm_doubletap", Player).GetBool()) { DoubleTapCheck(); }
		if(CheckForWallJump) { DashInitiator(); }
		if(CheckForWSlide) { WallSlideInitiator(); }
		
		///////////////////////////////////////////
		//Actual Movement
		if(MoveVec.Length())
		{
			MoveVec = 2 * max(1.0, MaximumGroundSpeed / 10.) * MoveVec.Unit();
			
			if((Vel.XY + MoveVec).Length() > MaximumGroundSpeed)
				Vel.XY = (Vel.XY + MoveVec).Unit() * MaximumGroundSpeed;
			else
				Vel.XY += MoveVec;
		}
		else
		{
			if(Vel.XY.Length() > 2.)
				Vel.XY -= 1.5 * Vel.XY.Unit();
			else
				Vel.XY = (0, 0);
		}
		
		// Sprite Animation
		PlayIdle();
		
		//Quake slide duration
		if(zm_cslidetype && !Player.OnGround)
			QSlideDuration++;
		else
			QSlideDuration = 0;
	}
	
	//////////////////////////////////////
	// Dusk
	
	Virtual void DuskAirMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		MoveVec = RotateVector((cmd.forwardmove, - cmd.sidemove), Angle);
		
		//Dashing / WallSliding
		if(CVar.GetCVar("zm_doubletap", Player).GetBool()) { DoubleTapCheck(); }
		if(CheckForWallJump) { DashInitiator(); }
		if(CheckForWSlide) { WallSlideInitiator(); }
		
		// Sudden mouse/keys turns penalization
		Double Direction;
		if(MoveVec.Length()) { Direction = VectorAngle(cmd.forwardmove, cmd.sidemove); }
		if(!Penalizer)
		{
			if((abs(cmd.Yaw) > 3640 || abs(Direction - OldMoveVecAngle) == 180) && Vel.XY.Length() > MaximumGroundSpeed)
			{
				Penalizer = Vel.XY.Length() / 4;
				MaximumHopSpeed *= 0.75;
			}
		}
		else if(Penalizer)
		{
			Penalizer--;
		}
		
		///////////////////////////////////////////
		//Actual Movement
		if(Penalizer || !MoveVec.Length())
		{
			if(Vel.XY.Length() > 2.)
				Vel.XY -= 1.5 * Vel.XY.Unit();
			else
				Vel.XY = (0, 0);
		}
		else
		{
			MoveVec = 4.5 * max(Vel.XY.Length() / 10., 1) * MoveVec.Unit();
			
			if(Player.OnGround && cmd.forwardmove && cmd.sidemove)
				MaximumHopSpeed = clamp(MaximumHopSpeed + dsk_acceleration * (Vel.XY.Length() >= dsk_escapespeed ? dsk_accelbonus : 1) * Speed, MaximumGroundSpeed, zm_topairspeed);
			else
				MaximumHopSpeed = clamp(MaximumHopSpeed, MaximumGroundSpeed, zm_topairspeed);
				
			if((Vel.XY + MoveVec).Length() > MaximumHopSpeed)
				Vel.XY = (Vel.XY + MoveVec).Unit() * MaximumHopSpeed;
			else
				Vel.XY += MoveVec;
				
			OldMoveVecAngle = Direction;
		}
		
		// Sprite Animation
		PlayIdle();
		
		//Quake slide duration
		if(zm_cslidetype && !Player.OnGround)
			QSlideDuration++;
		else
			QSlideDuration = 0;
	}
	
	//////////////////////////////////////
	// PainKiller
	
	Virtual void TrickJumpCheck()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		if(abs(GetZAt(0, 0) - Pos.Z) > 16)
		{
			if((cmd.forwardmove || cmd.sidemove) && Vel.XY dot RotateVector((cmd.forwardmove, - cmd.sidemove), Angle) <= 0) //if you try to 180 with directional keys you slow down
			{
				Penalizer = 1;
				MaximumHopSpeed = MaximumGroundSpeed;
			}
			else
			{
				TrickJumpAngle = Angle;
			}
		}
	}
	
	Virtual void PainkillerAirMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		///////////////////////////////////////////
		//Actual Movement
		Bool DirInput = cmd.forwardmove || cmd.sidemove;
		MaximumHopSpeed = Vel.XY.Length();
		if(Vel.XY.Length() <= 8. && (Penalizer || !DirInput))
		{
			MoveVec = (0, 0);
			Vel.XY = (0, 0);
			Penalizer = 0;
		}
		
		if(Penalizer)
		{
			Vel.XY -= 0.1 * Vel.XY.Unit();
		}
		else
		{
			if(Player.OnGround)
			{
				if(DirInput && !Pain)
				{
					MoveVec = 30.0 * (cmd.forwardmove, - cmd.sidemove).Unit(); //*slaps roof of PKMovement* this bad boy can go from 0 to 30u/s in one 35th of a second
					MaximumHopSpeed = clamp(Vel.XY.Length() + (cmd.forwardmove && !cmd.sidemove ? pk_acceleration * Speed : 0), MaximumGroundSpeed, zm_topairspeed);
					PKAirControl = 1;
				}
				else
				{
					MaximumHopSpeed = max(MaximumHopSpeed - 2. * pk_acceleration / Speed, !DirInput ? 0 : MaximumGroundSpeed);
					PKAirControl = 0.015;
				}
			}
			else if(!ZMJumpTics && PKAirControl < 2)
			{
				if(DirInput)
					MoveVec = 30.0 * (cmd.forwardmove, - cmd.sidemove).Unit();
				else
					MoveVec = (0, 0);
				PKAirControl = 2; //used as an outlandish value for trigger
			}
			
			// Trickjump parameters
			TrickJumpCheck();
			
			Vector2 Acceleration = RotateVector(MoveVec, Angle) * min(PKAirControl, 1);
			if((Vel.XY + Acceleration).Length() > MaximumHopSpeed)
				Vel.XY = (Vel.XY + Acceleration).Unit() * MaximumHopSpeed;
			else
				Vel.XY += Acceleration;
		}
		
		//Quake slide duration
		if(zm_cslidetype && !Player.OnGround)
			QSlideDuration++;
		else
			QSlideDuration = 0;
	}
	
	//////////////////////////////////////
	// Quake
	
	Virtual void QuakeAirMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		MoveVec = RotateVector((cmd.forwardmove, - cmd.sidemove), Angle);
		
		//Dashing / Crouch Slide
		if(CVar.GetCVar("zm_doubletap", Player).GetBool()) { DoubleTapCheck(); }
		if(CheckForWallJump) { DashInitiator(); }
		if(CheckForWSlide) { WallSlideInitiator(); }
		
		/////////////////////////////////////////////////////////////////////////
		// Actual Movement
		
		//Friction
		if(Player.OnGround) { QFriction(zm_topairspeed, 1.0); }
		//Acceleration
		if(MoveVec.Length())
		{
			if(!q_strafetype)
			{
				QAcceleration((MoveVec.Unit(), 0), MaximumGroundSpeed, q_3airaccel);
			}
			else if(q_strafetype == 1)
			{
				QAcceleration((MoveVec.Unit(), 0), q_1airaccel, 106.f);
			}
			else
			{
				if(cmd.sidemove && !cmd.forwardmove)
					QAcceleration((MoveVec.Unit(), 0), q_1airaccel, 106.f);
				else
					QAcceleration((MoveVec.Unit(), 0), MaximumGroundSpeed, q_3airaccel);
			}
			
			if(Vel.XY.Length() < MaximumGroundSpeed) { Vel.XY = MaximumGroundSpeed * Vel.XY.Unit(); }
		}
		
		// Sprite Animation
		PlayIdle();
		
		//Quake slide duration
		if(zm_cslidetype && !Player.OnGround)
			QSlideDuration++;
		else
			QSlideDuration = 0;
	}
	
	//////////////////////////////////////
	// Unreal Tournament
	
	Virtual void UTAirMove()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		MoveVec = RotateVector((cmd.forwardmove, - cmd.sidemove), Angle);
		if(MoveVec.Length()) { MoveVec = MoveVec.Unit() * 0.62; }
		
		//Dashing / Crouch Slide
		if(CVar.GetCVar("zm_doubletap", Player).GetBool()) { DoubleTapCheck(); }
		if(CheckForWallJump) { DashInitiator(); }
		if(CheckForWSlide) { WallSlideInitiator(); }
		
		/////////////////////////////////////////////////////////////////////////
		// Actual Movement	
		if((Vel.XY + MoveVec).Length() > MaximumGroundSpeed)
			Vel.XY = (Vel.XY + MoveVec).Unit() * MaximumGroundSpeed;
		else
			Vel.XY += MoveVec;
		
		// Sprite Animation
		PlayIdle();
		
		//Quake slide duration
		if(zm_cslidetype && !Player.OnGround)
			QSlideDuration++;
		else
			QSlideDuration = 0;
	}
	
	//////////////////////////////////////////
	// Crouching							//
	//////////////////////////////////////////
	
	//////////////////////////////////////////
	// Regular crouching
	
	Override void CheckCrouch(bool totallyfrozen)
	{
		let player = self.player;
		UserCmd cmd = player.cmd;

		if(cmd.buttons & BT_JUMP)
		{
			cmd.buttons &= ~BT_CROUCH;
		}
		
		if(player.health > 0)
		{
			if (!totallyfrozen)
			{
				int crouchdir = player.crouching;

				if(crouchdir == 0 && WaterLevel < 2 && !bNOGRAVITY)
				{
					crouchdir = (cmd.buttons & BT_CROUCH) ? -1 : 1;
				}
				else if (cmd.buttons & BT_CROUCH)
				{
					player.crouching = 0;
				}
				
				if(crouchdir == 1 && player.crouchfactor < 1 && pos.Z + height < ceilingz)
				{
					CrouchMove(1);
				}
				else if(crouchdir == -1 && player.crouchfactor > 0.5)
				{
					CrouchMove(-1);
				}
			}
		}
		else
		{
			player.Uncrouch();
		}

		player.crouchoffset = -(ViewHeight) * (1 - player.crouchfactor);
	}
	
	Override void CrouchMove(int direction)
	{
		let player = self.player;
		
		double defaultheight = FullHeight;
		double savedheight = Height;
		double crouchspeed = (CanCSlide && !zm_cslidetype ? - 1.5 : direction) * CROUCHSPEED;
		double oldheight = player.viewheight;

		player.crouchdir = direction;
		player.crouchfactor += crouchspeed;

		// check whether the move is ok
		Height  = defaultheight * player.crouchfactor;
		if (!TryMove(Pos.XY, false, NULL))
		{
			Height = savedheight;
			if (direction > 0)
			{
				// doesn't fit
				player.crouchfactor -= crouchspeed;
				return;
			}
		}
		Height = savedheight;

		player.crouchfactor = clamp(player.crouchfactor, 0.5, 1.);
		player.viewheight = ViewHeight * player.crouchfactor;
		player.crouchviewdelta = player.viewheight - ViewHeight;

		// Check for eyes going above/below fake floor due to crouching motion.
		CheckFakeFloorTriggers(pos.Z + oldheight, true);
	}
	
	//////////////////////////////////////////
	// Crouch Sliding
	Virtual void CSlideInitiator()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		if(WaterLevel >= 2 || bNOGRAVITY)
		{
			CSlideStartTime = 1;
			MaximumSlideSpeed = 0;
			CanCSlide = False;
			return;
		}
		else if(Player.OnGround && Player.CrouchFactor == 1 && CSlideStartTime)
		{
			CSlideStartTime = 0;
			MaximumSlideSpeed = 0;
			CanCSlide = False;
			return;
		}
		
		if(abs(Pos.Z - GetZAt(0,0)) <= 16 && Player.CrouchFactor != 1 && CheckInventory("Kicking",1))
		{
			if(!CSlideStartTime && (cmd.forwardmove || cmd.sidemove))
			{
				//Not enough space for a slide
				FLineTraceData DirTrace;
				Double SlideAngle = Angle - VectorAngle(cmd.forwardmove, cmd.sidemove);
				LineTrace(SlideAngle, Radius * 2, 0, 0, Height * 0.5, data: DirTrace);		
				if(DirTrace.Distance < Radius * 2) { return; }
				
				if(!zm_cslidetype)
				{
					CanCSlide = True;
					A_PlaySound("SlideKick/Start",CHAN_BODY);
					A_GiveInventory("CanSlideKick");
					CSlideVelocity = min(zm_cslidestrength * MaximumGroundSpeed, zm_topairspeed);
					Vel.XY = CSlideVelocity * AngleToVector(SlideAngle);
				}
				else if(QSlideDuration)
				{
					CanCSlide = True;
				}
				
				if(zm_cslidetype) { CSlideStartTime = Level.MapTime; }
			}
			
			if(!zm_cslidetype) { CSlideStartTime = Level.MapTime; }
		}
	}
	
	Virtual void CSlideMovePlayer()
	{
		Let Player = Self.Player;
		UserCmd cmd = player.cmd;
		
		MoveVec = RotateVector((cmd.forwardmove, - cmd.sidemove), Angle);
		if(MoveVec.Length()) { MoveVec = 2. * MoveVec.Unit(); }
		MaximumHopSpeed = MaximumGroundSpeed;
		
		///////////////////////////////////////////
		//Actual CSliding
		Vel.XY *= 0.8; //relatively loose friction
		
		if(!Player.OnGround && abs(Pos.Z - GetZAt(0,0)) > 16)
		{
			CSlideVelocity *= 0.96; //air friction	
			Vel.XY = (Vel.XY + MoveVec).Unit() * CSlideVelocity;
			
			if(Vel.XY.Length() <= MaximumGroundSpeed)
			{
				CanCSlide = False;
				A_PlaySound("SlideKick/Stop", CHAN_BODY);
				A_TakeInventory("CanSlideKick");
				return;
			}
		}
		else
		{
			if(Level.MapTime <= CSlideStartTime + zm_cslideduration)
			{	
				Vel.XY = (Vel.XY + MoveVec).Unit() * CSlideVelocity;
			}
			else if(Vel.XY.Length() <= MaximumGroundSpeed)
			{
				CanCSlide = False;
				A_TakeInventory("CanSlideKick");
				return;
			}
			else
			{	
				Vel.XY = (Vel.XY + MoveVec).Unit() * Vel.XY.Length();
				CSlideVelocity = Vel.XY.Length();
			}
		}
			
		//If you collide with something you lose it all, remove this check to make GZDoom randomly crash when you hit a wall during a slide
		FLineTraceData DirTrace;
		LineTrace(VectorAngle(Vel.X, Vel.Y), 100, 0, 0, 42, data: DirTrace); //check at 3/4ths of regular DoomGuy height
		if(DirTrace.Distance < 100) { 
			CanCSlide = False; 
			A_PlaySound("SlideKick/Stop", CHAN_BODY);
			A_TakeInventory("CanSlideKick");
		}
		
		// Sprite Animation
		PlayIdle();
	}
	
	Virtual void QSlideMovePlayer()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		MoveVec = RotateVector((cmd.forwardmove, - cmd.sidemove), Angle);
		
		if(Level.MapTime > CSlideStartTime + QSlideDuration || !Player.OnGround || !MoveVec.Length() || Vel.XY.Length() < MaximumSlideSpeed - 4)
		{
			CanCSlide = False;
			MaximumSlideSpeed = 0;
			QSlideDuration = 0;
		}
		else
		{
			if(!MaximumSlideSpeed)
			{
				MaximumSlideSpeed = Vel.Length();
				QSlideDuration *= 2;
			}
			A_PlaySound("WallSlide", CHAN_BODY, 0.5, True);
		}
		
		///////////////////////////////////////////
		//Actual Movement
		//Friction
		QFriction(MaximumGroundSpeed, 6.0);
		//Acceleration
		if(MoveVec.Length()) { 
			QAcceleration((MoveVec.Unit(), 0), max(MaximumSlideSpeed, MaximumGroundSpeed), zm_qslideaccel); 
		}
		
		//To cease CSlide under certain circumstances
		CSlideInitiator();
		
		//Sprite Animation
		PlayIdle();
	}
	
	//////////////////////////////////////
	// Dashing							//
	//////////////////////////////////////
	
	Virtual void DashMovePlayer() //pretty much an almost identical copy of UTAirMove() to uniform behavior during acrobatics
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		MoveVec = RotateVector((cmd.forwardmove, - cmd.sidemove), Angle);
		if(MoveVec.Length()) { MoveVec = MoveVec.Unit() * 0.62; }
		MaximumHopSpeed = clamp(Vel.XY.Length(), MaximumGroundSpeed, zm_topairspeed);
		
		//Dashing / WallJumping Sliding
		if(CVar.GetCVar("zm_doubletap", Player).GetBool()) { DoubleTapCheck(); }
		if(CheckForWallJump) { DashInitiator(); }
		if(CanDash) { Dash(); }
		if(CheckForWSlide) { WallSlideInitiator(); }
		if(CanWallSlide) { WallSlide(); }
		
		//Actual Movement
		if(!CanWallSlide)
		{
			if((Vel.XY + MoveVec).Length() > MaxDashLength)
				Vel.XY = (Vel.XY + MoveVec).Unit() * Vel.XY.Length();
			else
				Vel.XY += MoveVec;
		}
		
		// Sprite Animation
		PlayIdle();
	}
	
	Virtual void QDashMovePlayer()
	{
		Let Player = Self.Player;
		UserCmd cmd = Player.cmd;
		
		MoveVec = RotateVector((cmd.forwardmove, - cmd.sidemove), Angle);
		
		//Dashing / WallJumping Sliding
		if(CVar.GetCVar("zm_doubletap", Player).GetBool()) { DoubleTapCheck(); }
		if(CheckForWallJump) { DashInitiator(); }
		if(CanDash) { Dash(); }
		if(CheckForWSlide) { WallSlideInitiator(); }
		if(CanWallSlide) { WallSlide(); }
		
		//Actual Movement
		if(!CanWallSlide)
		{
			//Friction
			if(Player.OnGround) { QFriction(zm_topairspeed, 1.0); }
			//Acceleration
			if(MoveVec.Length())
			{
				if(!q_strafetype)
				{
					QAcceleration((MoveVec.Unit(), 0), MaximumGroundSpeed, q_3airaccel);
				}
				else if(q_strafetype == 1)
				{
					QAcceleration((MoveVec.Unit(), 0), q_1airaccel, 106.f);
				}
				else
				{
					if(cmd.sidemove && !cmd.forwardmove)
						QAcceleration((MoveVec.Unit(), 0), q_1airaccel, 106.f);
					else
						QAcceleration((MoveVec.Unit(), 0), MaximumGroundSpeed, q_3airaccel);
				}
				
				if(Vel.XY.Length() < MaximumGroundSpeed) { Vel.XY = MaximumGroundSpeed * Vel.XY.Unit(); }
			}
		}
		
		// Sprite Animation
		PlayIdle();
	}
	
	Virtual void DoubleTapCheck()
	{
		Let Player = Self.Player;
		UserCmd cmd = player.cmd;
		
		Int	MaxTapTime = CVar.GetCVar("zm_maxtaptime", Player).GetInt();
		Int TapValue = (cmd.buttons & BT_FORWARD) + (cmd.buttons & BT_BACK) + (cmd.buttons & BT_MOVERIGHT) + (cmd.buttons & BT_MOVELEFT);
		Int	SecondTapValue;
		
		if(TapValue & ~OldTapValue)
		{
			if(!FirstTapValue)
			{
				FirstTapTime = Level.MapTime;
				FirstTapValue = TapValue;
			}
			else
			{
				if(TapValue != FirstTapValue)
				{
					FirstTapTime = 0;
					FirstTapValue = 0;
				}
				else
				{
					SecondTapValue = TapValue;
				}
			}
		}
		
		if((FirstTapValue && SecondTapValue) || Level.Maptime > FirstTapTime + MaxTapTime)
		{
			if(SecondTapValue && Level.MapTime <= FirstTapTime + MaxTapTime) { DashInitiator(); }
			FirstTapValue = 0;
			FirstTapTime = 0;
		}
		
		OldTapValue = TapValue;
	}
	
	Virtual void DashInitiator()
	{
		Let Player = Self.Player;
		UserCmd cmd = player.cmd;
		
		if(WaterLevel >= 2 || bNOGRAVITY || BlockJump || Player.CrouchFactor != 1)
		{
			CheckForWallJump = 0;
			Return;
		}
			
		///////////////////////////////////////////////////////
		
		if(zm_dash && Player.OnGround && !Jumping && !DashCooler && (cmd.sidemove || cmd.forwardmove) && !CheckForWallJump)
		{
			CanDash = True;
			return;
		}
			
		if(!Player.OnGround && zm_wjump)
		{
			if(!CheckForWallJump)
				CheckForWallJump = 6;
			else
				CheckForWallJump--;
			
			if(cmd.sidemove || cmd.forwardmove)
			{
				FLineTraceData WallCheck;
				FLineTraceData DirTrace;
				Vector2 WallDir;
				Double WallDistance;
					
				Int w;
				for(w = 0; w < 8; w++)
				{
					//Wall proximity check
					LineTrace(w * 45, Radius + 17, 0, TRF_THRUACTORS, data: WallCheck);
						
					if((!WallDistance && WallCheck.Distance <= Radius + 16) || WallCheck.Distance <= WallDistance) //Check for the minimum distance
					{
						WallDistance = WallCheck.Distance;
						WallDir = WallCheck.HitDir.XY;
					}
				}
					
				//No obstacles near player check
				LineTrace(Angle - VectorAngle(cmd.forwardmove, cmd.sidemove), Radius + 33, 0, TRF_THRUACTORS, data: DirTrace);
							
				if(DirTrace.Distance >= Radius + 32 && WallDistance)
				{
					Vector2 PlayerDir = DirTrace.HitDir.XY;
					Double DirDelta = abs(acos(WallDir dot PlayerDir));
					if(DirDelta > 92)
					{
						CanChainJump = True;
						CanDash = True;
						CheckForWallJump = 0;
					}	
				}
				else
				{
					CheckForWallJump = 0;
				}
			}
		}
		else
		{
			CheckForWallJump = 0;
		}
	}
	
	Virtual void Dash()
	{
		Let Player = Self.Player;
		UserCmd cmd = player.cmd;
		
		if((MaxDashLength && Player.OnGround) || bNOGRAVITY || WaterLevel >= 2)
		{
			CanDash = False;
			MaxDashLength = 0;
			DashSpeed = 0;
			DashCooler = zm_dashcooler;
			DashNumber = 0;
			A_TakeInventory("PlayerDashed");
			return;
		}
		else
		{
			DashRecovery = 3;
			
			if(CanChainJump)
			{
				//Stop any eventual WallSlide
				A_StopSound(CHAN_BODY);
				SlideVelocity = (0, 0);
				CanWallSlide = False;
				//Take care of actual walljump stuff
				MaxDashLength = 0;
				if(zm_wjdoublejumprenew) { CanDoubleJump = True; } 
				CanChainJump = False;
			}
				
			if(!MaxDashLength)
			{
				DashNumber++;
				
				if(DashNumber <= 2)
				{
					Double jumpvelz = zm_jumpheight * zm_dashheight + ElevatorJumpBoost;
					Double jumpfac = 0;
						
					Vel.Z = jumpvelz;
				}
				
				ZMJumpTics = True;
				bOnMobj = false;
				
				if(!(player.cheats & CF_PREDICTING)) { A_PlaySound("JMPBOOT", CHAN_BODY); }
				
				if(!DashSpeed)
				{
					Float EstimatedDashSpeed1 = (Player.OnGround ? zm_dashboost : zm_wjumpboost) * MaximumGroundSpeed;
					Float EstimatedDashSpeed2 = zm_multipledashes + Vel.XY.Length();
					DashSpeed = max(EstimatedDashSpeed1, EstimatedDashSpeed2);
				}
				else
				{
					DashSpeed = zm_multipledashes + max(DashSpeed, Vel.XY.Length());
				}
				A_GiveInventory("PlayerDashed");
				Vel.XY = min(DashSpeed, zm_topairspeed) * AngleToVector(Angle - VectorAngle(cmd.forwardmove , cmd.sidemove));
				MaxDashLength = Vel.XY.Length();
			}
		}
	}
	
	Virtual void WallSlideInitiator()
	{
		Let Player = Self.Player;
		UserCmd cmd = player.cmd;
		
		if(!zm_wslide) return;
		
		if(!Player.OnGround && !CheckForWSlide && !CanWallSlide)
			CheckForWSlide = 24;
		else if(CanWallSlide)
			return;
		
		if(Player.OnGround)
		{
			CheckForWSlide = 0;
			return;
		}
		else
		{
			CheckForWSlide--;
			
			FLineTraceData DirTrace;
			Int SlideAngleDelta;
			
			if(!SlideVelocity.Length())
			{
				LineTrace(VectorAngle(Vel.X, Vel.Y), 100, 0, TRF_THRUACTORS, data: DirTrace);
				if(DirTrace.Distance < 100) { SlideVelocity = Vel.XY; }
			}
			else
			{
				SlideAngleDelta = abs(acos(SlideVelocity.Unit() dot Vel.XY.Unit())); //all of this otherwise it glitches out and returns outlandishly low values
			}
			
			if(SlideAngleDelta && SlideAngleDelta < 45 && SlideAngleDelta > 0)
			{
				SlideSpeed = SlideVelocity.Length();
				SlideVelocity = SlideSpeed * Vel.XY.Unit();
				Vel.XY = SlideVelocity;
				CanWallSlide = True;
				CheckForWSlide = 0;
				return;
			}
		}
	}
	
	Virtual void WallSlide()
	{
		Let Player = Self.Player;
		UserCmd cmd = player.cmd;
		
		CanWallSlide = False; //assume wallslide failed until proven wrong
		
		if(Player.OnGround || WaterLevel >= 2 || bNOGRAVITY)
		{
			SlideVelocity = (0, 0);
			A_StopSound(CHAN_BODY);
			return;
		}
		
		//////////////////////////////////////////////////////
		//Dumb ways to fail...so many don't waste your time
		
		//WallCheck
		Int i;
		for(i = 0; i < 8; i++)
		{
			FLineTraceData SlideWallCheck;
			LineTrace(i * 45, (Radius * 3) / 2, 0, TRF_THRUACTORS, data: SlideWallCheck);
			if(SlideWallCheck.Distance < (Radius * 3) / 2) { CanWallSlide = True; }
		}
		
		//No directional inputs
		if(CanWallSlide && !cmd.forwardmove && !cmd.sidemove) { CanWallSlide = False; } //no need to calculate these if Wall Slide has already failed
		
		//Moving away from wall
		if(CanWallSlide)
		{
			Double	WishDirection = Angle - VectorAngle(cmd.forwardmove, cmd.sidemove);
			Vector2	DirVector = (cos(WishDirection), sin(WishDirection));
			Double	DirAngle = abs(acos(DirVector.Unit() dot Vel.XY.Unit()));
			
			if(DirAngle >= 45)
			{
				if(DirAngle >= 90)
				{
					CanWallSlide = False;
				}
				else //if you are moving toward the wall but angle is less than 90 you will be fine
				{
					FLineTraceData DirTrace;
					LineTrace(VectorAngle(DirVector.X, DirVector.Y), 100, 0, TRF_THRUACTORS, data: DirTrace);		
					if(DirTrace.Distance > 90) { CanWallSlide = False; }
				}
			}
		}
		
		//Wall changed angle
		if(CanWallSlide)
		{
			Int SlideAngleDelta = abs(acos(SlideVelocity.Unit() dot Vel.XY.Unit()));
			if(SlideAngleDelta && SlideAngleDelta <= 60 && SlideAngleDelta > 0)
			{
				SlideVelocity = SlideSpeed * Vel.XY.Unit();
				Vel.XY = SlideVelocity; //needed to not make velocity check fail
			}
			else if(SlideAngleDelta > 45)
				CanWallSlide = False;
		}
		
		//You hit the wall Jack, so don't come back no more
		if(CanWallSlide && Vel.XY.Length() <= MaximumGroundSpeed) { CanWallSlide = False; }
		
		//////////////////////////////////////////////////////
		
		Vel.XY = SlideVelocity;
		Vel.Z *= zm_wslidevelz;	
		
		if(!CanWallSlide)
		{
			SlideVelocity = (0, 0);
			A_StopSound(CHAN_BODY);
		}
		else
			A_PlaySound("WallSlide", CHAN_BODY, 0.3, True);
	}
	
	//////////////////////////////////////
	// Bobbing							//
	//////////////////////////////////////
	
	Override Vector2 BobWeapon (double ticfrac)
	{
		Vector2 p1, p2, r;
		Vector2 result;

		float bobtarget;

		let player = self.player;
		UserCmd cmd = player.cmd;
		
		if (!player) return (0, 0);
		let weapon = player.ReadyWeapon;
		
		if(!(player.WeaponState & WF_WEAPONBOBBING)) //needs to be here instead of BobCounter cause BobWeapon is called multiple times per tic
		{
			MoveFakeTime = 0;
			StillFakeTime = 0;
			XBobOffset = 0;
			XBob = 0;
			YBob = 0;
		}
		
		if(weapon == null || weapon.bDontBob)
			return (0, 0);
		
		/////////////////////////////////////////
		//Bob Counter
		
		if(Level.Maptime != PreviousTic && BobType) //because BobWeapon is called multiple times per tic
		{
			if(!ZMJumpTics && Pos.Z - GetZAt(0,0) <= 16 && !DashRecovery && !HoppingBob) //going down steps is not considered being in mid air
			{
				if((!cmd.forwardmove && !cmd.sidemove) || CanCSlide)
				{
					if(!StillFakeTime)
						StillFakeTime = randompick(61,121); //random chance to start bobbing up or down
					else
						StillFakeTime++;
							
					MoveFakeTime = 0;
				}
				else
				{
					if(!MoveFakeTime)
					{
						MoveFakeTime = BobType == 1 ? randompick(33,49) : randompick(9,25); //random chance to start bobbing left or right
						StillFakeTime = 0;
					}
					else
					{
						Double WalkBobMulti = min(Vel.XY.length(), MaximumGroundSpeed);
						MoveFakeTime += max(WalkBobMulti / MaximumGroundSpeed, 0.6); //no weird weapon warp when going from walking to running and viceversa
					}
				}
			}
			else
			{
				MoveFakeTime = 0;
				StillFakeTime = 0;
				HoppingBob = True;
			}
			
			PreviousTic = Level.Maptime;
		}
		
		/////////////////////////////////////////

		int bobstyle = weapon.BobStyle;
		double BobSpeed = (weapon.BobSpeed * 128);
		double Rangex = weapon.BobRangeX;
		double Rangey = weapon.BobRangeY;
		
		for (int i = 0; i < 2; i++)
		{
			double angle = (BobSpeed * player.GetWBobSpeed() * (Level.maptime - 1 + i)) * (360. / 8192.);
			
			//////////////////////////////
			//Yaw Weapon Sway
			
			Bool SwayAllowed = CVar.GetCVar("zm_yawsway", Player).GetBool();
			
			if(SwayAllowed)
			{
				Double	SwaySpeed = CVar.GetCVar("zm_yawswayspeed", Player).GetFloat() / 50;
				Double 	SwayRange = CVar.GetCVar("zm_yawswayrange", Player).GetFloat() * 10;
				Double	SwayFrictionMulti = CVar.GetCVar("zm_yawswayfriction", Player).GetFloat() / 10;
				Int		SwayDirection = CVar.GetCVar("zm_yawswaydirection", Player).GetBool() ? -1 : 1;
				
				Double Yaw = cmd.Yaw * (360.0 / 65536.0);
				XBobOffset += SwayDirection * Yaw * SwaySpeed;
				
				Bool SwayTarget = Yaw ? False : True;
				if(abs(XBobOffset) > 0.2)
					XBobOffset -= XBobOffset / ((1.5 - SwayFrictionMulti) * 100);
				else if(SwayTarget)
					XBobOffset = 0;
				
				XBobOffset = clamp(XBobOffset, - SwayRange, SwayRange);
			}
			else
				XBobOffset = 0;
				
			//////////////////////////////
			
			BobType = CVar.GetCVar("zm_bobtype", Player).GetInt();
			
			if(BobType)
			{
				angle = (256. * (MoveFakeTime - 1 + i)) * (360. / 8192.);
				Double StillRange = CVar.GetCVar("zm_stillbobrange", Player).GetFloat();
				Double StillSpeed = CVar.GetCVar("zm_stillbobspeed", Player).GetFloat();
				
				if(BobType == 2)
				{
					/////////////////////////////////
					//X Swaying
					
					if(SwayAllowed)
					{
						Xbob = XBobOffset;
					}
					else
					{
						Double	RangeX = CVar.GetCVar("dsk_xswayrange", Player).GetFloat() * 10;
						Double	SpeedX = CVar.GetCVar("dsk_xswayspeed", Player).GetFloat();
						
						if(!cmd.Sidemove)
						{
							XBob += abs(XBob) > 0.2 ? (XBob > 0 ? -1 : 1) * 0.06 * SpeedX : 0;
						}
						else if(!Player.OnGround && ZMJumpTics)
						{
							XBob += (cmd.buttons & BT_MOVERIGHT ? 1 : -1) * 0.06 * SpeedX;
							XBob = clamp(XBob, - RangeX, RangeX);
						}
					}
					
					/////////////////////////////////
					//Y Bobbing
					
					Double	RangeY = CVar.GetCVar("dsk_ybobrange", Player).GetFloat();
					Double	SpeedY = CVar.GetCVar("dsk_ybobspeed", Player).GetFloat();
					Double	YHeight = MaximumGroundSpeed * RangeY;
					
					if(HoppingBob)
					{
						if(Player.OnGround && !Jumping)
						{
							YBob *= abs(YBob) > 0.1 ? 0.988 : 0;
							if(!YBob) { HoppingBob = False; }
						}
						else
						{
							Float OffsetSpeed = CVar.GetCVar("zm_offsetspeed", Player).GetInt();
							Float OffsetRange = CVar.GetCVar("zm_offsetmaxrange", Player).GetInt();
							
							if(Xbob) { XBob *= abs(XBob) > 0.2 ? 0.988 : 0; }
							
							if(Vel.Z >= 0)
								YBob -= Vel.Z / OffsetSpeed * 2. * max(abs(YBob) / OffsetRange, 1);
							else
								YBob -= Vel.Z / OffsetSpeed * (1 - abs(YBob) / OffsetRange);	
							YBob = clamp(YBob, - (BobType == 1 ? StillRange : YHeight), OffsetRange);
						}
					}
					else if(StillFaketime || MoveFakeTime)
					{
						if(!StillFakeTime)
						{
							YBob = YHeight * (cos(angle * SpeedY));
							CenterAligned = False;
						}
						else
						{
							if(!CenterAligned)
							{
								YBob *= abs(YBob) > 0.2 ? 0.985 : 0;
								if(!YBob) { CenterAligned = True; }
							}
							else
							{
								Double StillAngle = StillFakeTime / 120. * 360.;
								YBob = StillRange * sin(StillAngle * StillSpeed);
							}
						}
					}
					
					r = (XBob, YBob + YHeight);
				}
				else
				{
					Double 	BobSpeed, RangeY, YHeight, RangeX, XLength, HoppingRange;
					
					if(BobType == 1)
					{
						BobSpeed = CVar.GetCVar("be_bobspeed", Player).GetFloat();
						RangeY = CVar.GetCVar("be_ybobrange", Player).GetFloat();
						YHeight = MaximumGroundSpeed * RangeY;
						RangeX = CVar.GetCVar("be_xbobrange", Player).GetFloat();
						XLength = MaximumGroundSpeed * RangeX;
						HoppingRange = CVar.GetCVar("be_hopbobrange", Player).GetFloat() * 5;
					}
					else if(BobType == 3)
					{
						BobSpeed = CVar.GetCVar("pk_bobspeed", Player).GetFloat();
						RangeY = CVar.GetCVar("pk_ybobrange", Player).GetFloat();
						YHeight = MaximumGroundSpeed * RangeY;
						RangeX = CVar.GetCVar("pk_xbobrange", Player).GetFloat();
						XLength = MaximumGroundSpeed * RangeX;
						HoppingRange = CVar.GetCVar("pk_hopbobrange", Player).GetFloat() * 5;
					}
					else if(BobType)
					{
						BobSpeed = CVar.GetCVar("ut_bobspeed", Player).GetFloat();
						RangeY = CVar.GetCVar("ut_ybobrange", Player).GetFloat() / 4;
						YHeight = MaximumGroundSpeed * RangeY;
						RangeX = CVar.GetCVar("ut_xbobrange", Player).GetFloat() / 2;
						XLength = MaximumGroundSpeed * RangeX;
						HoppingRange = CVar.GetCVar("ut_hopbobrange", Player).GetFloat() * 5;
					}
					
					if(HoppingBob)
					{
						if(Player.OnGround && !Jumping)
						{
							YBob *= abs(YBob) > 0.1 ? 0.988 : 0;
							if(!YBob) { HoppingBob = False; }
						}
						else
						{
							Float OffsetSpeed = CVar.GetCVar("zm_offsetspeed", Player).GetInt();
							Float OffsetRange = CVar.GetCVar("zm_offsetmaxrange", Player).GetInt();
							
							if(Xbob) { XBob *= abs(XBob) > 0.2 ? 0.988 : 0; }
							
							if(Vel.Z >= 0)
								YBob -= Vel.Z / OffsetSpeed * 2. * max(abs(YBob) / OffsetRange, 1);
							else
								YBob -= Vel.Z / OffsetSpeed * (1 - abs(YBob) / OffsetRange);	
							YBob = clamp(YBob, - (BobType == 1 ? StillRange : YHeight), OffsetRange);
						}
					}
					else if(StillFakeTime || MoveFakeTime)
					{
						if(!StillFakeTime)
						{
							if(BobType == 1)
							{
								XBob = XLength * sin(angle * BobSpeed);	
								YBob = YHeight * abs(sin(angle * BobSpeed));
							}
							else if(BobType == 3)
							{
								XBob = XLength * cos(angle * BobSpeed);	
								YBob = - YHeight * (1. - abs(sin(angle * BobSpeed)));
							}
							else if(BobType == 4)
							{
								XBob = XLength * cos(angle * BobSpeed);	
								YBob = YHeight * sin(2 * angle * BobSpeed);
							}
							
							CenterAligned = False;
						}
						else
						{
							if(!CenterAligned)
							{
								YBob *= abs(YBob) > 0.2 ? 0.985 : 0;
								XBob *= abs(XBob) > 0.2 ? 0.985 : 0;
								if(!YBob && !XBob) { CenterAligned = True; }
							}
							else
							{
								Double StillAngle = StillFakeTime / 120. * 360.;
								YBob = StillRange * sin(StillAngle * StillSpeed);
							}
						}
					}
						
					r = (XBob, YBob + (BobType == 1 ? StillRange : YHeight));
				}
			}
			else
			{
				bobtarget = double((player.WeaponState & WF_WEAPONBOBBING) ? player.bob : 0.);
			
				if(curbob != bobtarget)
				{
					if(abs(bobtarget - curbob) <= 1)
					{
						curbob = bobtarget;
					}
					else
					{
						double zoom = MAX(1., abs(curbob - bobtarget) / 40);
						if (curbob > bobtarget)
						{
							curbob -= zoom;
						}
						else
						{
							curbob += zoom;
						}
					}
				}
				
				if(curbob)
				{
					double bobx = (player.bob * Rangex * ViewBob);
					double boby = (player.bob * Rangey * ViewBob);
						
					switch (bobstyle)
					{
					case Bob_Normal:
						r.X = bobx * cos(angle);
						r.Y = boby * abs(sin(angle));
						break;

					case Bob_Inverse:
						r.X = bobx * cos(angle);
						r.Y = boby * (1. - abs(sin(angle)));
						break;

					case Bob_Alpha:
						r.X = bobx * sin(angle);
						r.Y = boby * abs(sin(angle));
						break;

					case Bob_InverseAlpha:
						r.X = bobx * sin(angle);
						r.Y = boby * (1. - abs(sin(angle)));
						break;

					case Bob_Smooth:
						r.X = bobx*cos(angle);
						r.Y = 0.5f * (boby * (1. - (cos(angle * 2))));
						break;

					case Bob_InverseSmooth:
						r.X = bobx*cos(angle);
						r.Y = 0.5f * (boby * (1. + (cos(angle * 2))));
					}
				}
				else
				{
					r = (0, 0);
				}
			}
			
			r.X += XBobOffset;
			
			if (i == 0) p1 = r; else p2 = r;
		}
		return p1 * (1. - ticfrac) + p2 * ticfrac;
	}
	
	// The rest of Project Brutality player class
	Default
	{
		PlayerPawnBase.TankTurretSpriteActor "TankTurretNotReal";
	}
	void SpawnTankSprite()
	{
		if (TankBaseSprite) return;
		TankBaseSprite = TankBaseNotReal(Spawn("TankBaseNotReal",self.pos + self.vel,ALLOW_REPLACE));
		TankTurretSprite = Spawn(TankTurretSpriteActor,self.pos + self.vel,ALLOW_REPLACE);
	}
	void DestroyTankSprites()
	{
		TankBaseSprite.Destroy();
		TankTurretSprite.Destroy();
		TankBaseSprite = NULL;
		TankTurretSprite = NULL;
	}
	void SetTankSpritePosition(int spritestate,double angle = 0)
	{
		if (TankBaseSprite != NULL)
		{
			TankBaseSprite.SetOrigin(self.pos + self.vel,true);
			TankBaseSprite.spritestate = spritestate;
			TankBaseSprite.angle = angle;
		}
	}
	
	void CheckTargetHitRegistration()
	{
		// Check the parent class the monster is derived from
		//let target_ptr = AAPTR_PLAYER_GETTARGET;
		if (CheckClass("PB_Monster", AAPTR_PLAYER_GETTARGET, TRUE)){
			//A_Print("This is a PB Monster!!!"); // Debug code
			A_GiveInventory("HeadshotToken", 1, AAPTR_PLAYER_GETTARGET);
		}
	}
	
	
	
	override void Die(Actor source, Actor inflictor, int dmgflags)
	{
		A_TakeInventory("CameraRunner",1);
		Super.Die(source, inflictor, dmgflags);
	}
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		if (!level.IsJumpingAllowed() || (player && player.mo && player.mo.JumpZ == 0)) A_GiveInventory("DoNotDoubleJump",1);
	}
	override void Tick()
	{
		Super.Tick();
		
		CheckTargetHitRegistration();
		
		//Screen Overlay Handlers
		if (CheckInventory("RedBloodSplatterz",1)) {
			A_TakeInventory("RedBloodSplatterz", 1);
			A_Giveinventory("BloodOnVisor",1);
			int selector = (random(0,1));
			if (selector == 0){ACS_NamedExecute("RedBloodSplatter580", 0);}
			if (selector == 1){ACS_NamedExecute("RedBloodSplatter580", 1);}
		}
		
		if (CheckInventory("BlueBloodSplatterz",1)) {
			A_TakeInventory("BlueBloodSplatterz", 1);
			A_Giveinventory("BlueBloodOnVisor",1);
			int selector = (random(0,1));
			if (selector == 0){ACS_NamedExecute("BlueBloodSplatter583", 0);}
		}
		if (CheckInventory("GreenBloodSplatterz",1)) {
			A_TakeInventory("GreenBloodSplatterz", 1);
			A_Giveinventory("GreenBloodOnVisor",1);
			int selector = (random(0,1));
			if (selector == 0){ACS_NamedExecute("GreenBloodSplatter582", 0);}
		}
		if (CheckInventory("BloodSplasherz",1)) {
			A_TakeInventory("BloodSplasherz", 1);
			A_Giveinventory("BloodOnVisor",1);
			int selector = (random(0,5));
			if (selector == 0){ACS_Execute(580, 0, 0, 0, 0);}
			if (selector == 1){ACS_Execute(581, 0, 0, 0, 0);}
			if (selector == 2){ACS_Execute(582, 0, 0, 0, 0);}
			if (selector == 3){ACS_Execute(583, 0, 0, 0, 0);}
			if (selector == 4){ACS_Execute(584, 0, 0, 0, 0);}
			if (selector == 5){ACS_Execute(585, 0, 0, 0, 0);}
		}
		if (CheckInventory("WaterSplasherz",1)) {
			A_TakeInventory("WaterSplasherz", 1);
			A_Giveinventory("WaterOnVisor",1);
			int selector = (random(0,4));
			if (selector == 0){ACS_Execute(550, 0, 0, 0, 0);}
			if (selector == 1){ACS_Execute(551, 0, 0, 0, 0);}
			if (selector == 2){ACS_Execute(552, 0, 0, 0, 0);}
			if (selector == 3){ACS_Execute(554, 0, 0, 0, 0);}
			if (selector == 4){ACS_Execute(555, 0, 0, 0, 0);}
		}
		if (CheckInventory("SlimeSplasherz",1)) {
			A_TakeInventory("SlimeSplasherz", 1);
			A_Giveinventory("SlimeOnVisor",1);
			int selector = (random(0,5));
			if (selector == 0){ACS_Execute(540, 0, 0, 0, 0);}
			if (selector == 1){ACS_Execute(541, 0, 0, 0, 0);}
			if (selector == 2){ACS_Execute(542, 0, 0, 0, 0);}
			if (selector == 3){ACS_Execute(543, 0, 0, 0, 0);}
			if (selector == 4){ACS_Execute(544, 0, 0, 0, 0);}
			if (selector == 5){ACS_Execute(545, 0, 0, 0, 0);}
		}
		if (CheckInventory("SludgeSplasherz",1)) {
			A_TakeInventory("SludgeSplasherz", 1);
			A_Giveinventory("SludgeOnVisor",1);
			int selector = (random(0,5));
			if (selector == 0){ACS_Execute(5530, 0, 0, 0, 0);}
			if (selector == 1){ACS_Execute(5531, 0, 0, 0, 0);}
			if (selector == 2){ACS_Execute(5532, 0, 0, 0, 0);}
			if (selector == 3){ACS_Execute(5533, 0, 0, 0, 0);}
			if (selector == 4){ACS_Execute(5534, 0, 0, 0, 0);}
			if (selector == 5){ACS_Execute(5535, 0, 0, 0, 0);}
		}
		
		if (CheckInventory("LavaSplasherz",1)) {
			A_TakeInventory("LavaSplasherz", 1);
			A_Giveinventory("LavaOnVisor",1);
			int selector = (random(0,5));
			if (selector == 0){ACS_NamedExecute("LavaScreenSplash550", 0);}
			if (selector == 1){ACS_NamedExecute("LavaScreenSplash551", 0);}
			if (selector == 2){ACS_NamedExecute("LavaScreenSplash552", 0);}
			if (selector == 3){ACS_NamedExecute("LavaScreenSplash553", 0);}
			if (selector == 4){ACS_NamedExecute("LavaScreenSplash554", 0);}
			if (selector == 5){ACS_NamedExecute("LavaScreenSplash555", 0);}
		}
		
		if (IsTank && !(health <= 0))
		{
			if (TankTurretSprite != NULL)
			{
				//TankTurretSprite.Tics = -1;
				TankTurretSprite.A_Setangle(self.angle,SPF_INTERPOLATE);
				TankTurretSprite.SetOrigin(self.pos + self.vel,true);
				TankTurretSprite.bINVISIBLE = false;
			}
			if (health < 500)
			{
				A_SpawnProjectile ("BigNeoSmoke", 0, 0, random (0, 360), 2, -random (0, 360));
				A_SpawnProjectile ("ExplosionSmoke", 0, 0, random (0, 360), 2, -random (0, 360));
			}
			if (health < 350)
			{
				A_SpawnProjectile ("BigNeoSmoke", 0, 0, random (0, 360), 2, -random (0, 360));
				A_SpawnProjectile ("ExplosionSmoke", 0, 0, random (0, 360), 2, -random (0, 360));
			}
			if (Health < 200)
			{
				A_SpawnProjectile ("BigBlackSmoke", 40, 0, random (0, 360), 2, -random (40, 160));
			}
			if (health < 30)
			{
				A_SpawnProjectile ("FlameThrowerFireParticles", 0, 0, random (0, 360), 2, -random (0, 360));
				A_Playsound("BDFireplace2", 1, 1, 1);
				tankdeathcounter += 1;
				if (tankdeathcounter >= (35 * 5))
				{
					tankdeathcounter = 0;
					A_Die();
				}
			}
		}
	}
}


//////////////////////////////////////
// EventHandlers					//
//////////////////////////////////////

//Edit of a SpeedOMeter from Gutawer
Class Speedometer : EventHandler
{
	override void renderOverlay(RenderEvent e)
	{
		if(CVar.FindCVar("zm_speedometer").GetBool())
		{
			let scalevec = statusbar.GetHUDScale();
			Vector2 scaler = (1 / scalevec.x, 1 / scalevec.y);
			Vector2 screenSize = (Screen.GetWidth() * scaler.x, Screen.GetHeight() * scaler.y);
		
			Vector2 drawPos = (-12 * (screenSize.x / 320), 106 * (screenSize.y / 200));
		
			Actor mo = players[consoleplayer].mo;
		
			if (mo != NULL)
			Screen.drawText(CONFONT, Font.CR_WHITE, drawPos.x, drawPos.y, String.format("%f", mo.Vel.XY.length()), DTA_HUDRules, true);
		}
	}
}

Class DashHandler : EventHandler
{
    Override void NetworkProcess(ConsoleEvent e)
    {
        If(e.Player >= 0 && PlayerInGame[e.Player] && Players[e.Player].Mo)
        {
            If (e.Name == "Dash")
            {
                Let DashPlayer = PlayerPawnBase(Players[e.Player].Mo);
                If(DashPlayer)
                {
                    DashPlayer.DashInitiator();
                }
            }
        }
    }
}

Class WallSlideHandler : EventHandler
{
    Override void NetworkProcess(ConsoleEvent e)
    {
        If(e.Player >= 0 && PlayerInGame[e.Player] && Players[e.Player].Mo)
        {
            If (e.Name == "WallSlide")
            {
                Let WSlidePlayer = PlayerPawnBase(Players[e.Player].Mo);
                If(WSlidePlayer)
                {
                    WSlidePlayer.WallSlideInitiator();
                }
            }
        }
    }
}